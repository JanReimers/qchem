Priority 1:
    -ID, streaming
        1) Test boost::serialization, does it work for shared pointers???
            Looks like yes, can std::shared_ptr in the headers.
        -We need a non-streamable UniqueID for caching GuassianCD amd RNLM objects.
        -Separate UniquesID from streaming
        -Get rid of ALL the old Read/Write.  Put (intrusive>?) boost::serialization code in one place.
        -What about pretty output?
        -boost::serialization of OML objects.

    -What can we use from boost:
        -Filesystem
        -Flyweight for GaussianCD s?
        -Foreach looping
        -iostream state saver.
        -iterator
        -Logging
        -Multi-index containers
        -MySQL
        -Pointer container, poly-container
        -Program options
        -Python interface generation.
        -Range 
        -uBlas,
        -units
        -Uuid
        -Boost::Serialize is what we need for saving and restoring object trees.
            Talks about boost::shared_pointer ... too old for sdt::shared_ptr?
            Need to try.
            
    -Make final Ham types Ham_HF_U Ham_HF_P, Ham_DFT_U ... etc.
    -Add A-PG_*_* tests.
    -put periodc table in spreadsheet and read in a csv file.
    -Use BasisSet interface to create charge and Vxc fitting basis sets.
    -Drop rc_ptr and use std::shared_ptr and std::unique_ptr.
        is std::vector<std::unique_ptr<T> > preferrable to optr_vector<T*>
        Done: FitFuncImp had shared_ptr for basis set and mesh.
        Use std:: for Cluster pointers.
    Done: -Fix all warnings.
    -Fix valgrind errors
        Seeing 1 errors related open MP
        Atom mesh leaks.  Should own radial and angular meshes?
    -kT Occ smearing fails miserably.
    -Clean up PolGaussian construction
    -Does UniqueID really need to enforce Read/Write?
        Tightly couple with PMStreamableObject which is tightly coupled with
        the Read/Write functions throughout.
        -Need a mile high plan to io before doing anything.
    Done: -Get all headers into include.
    -STO basis set for atoms.
        -Type out the integral formulas
        Done: -Use a static pascal triangle for I_k calculations.
        Done: -Get maxL=4 working (f g functions)
            Done: Need to automate the I_k expressions using binomial sum. 
        -Decouple n=l+1.  i.e. multiple ns for one l.  look up max(n) for a given Z?
        -One alpha=Z/n basis function, to satisfy the cusp condition.
        Done: -Start coding the BF/BS/IE classes.
        Done: -Test the integrals with numerical integrations.
            Fixed: Numerical repulsion integrals don't give the right numbers.
    -Make a new PolG::IntegralEngine using libcint
    -Automate exponents for slater orbitals.  0.5->1.5*Z ?
        Done: for testing.
    Done: -Re-org UT class network.  too many classes.
        Decouple
            Basis set type
            H type
                Some H types need fit basis sets.
            cluster type
                Some basis sets only work with atoms
        Use case:
    -SCFSupervisor class:
        Owns BS, H, WaveF, SCFIterator
    -Electron loading problem/buf for Z=55 and up
    -Why new SlaterExchange(exparam,Spin(Spin::Up)); for pol fit vxc?
                                    ^^^^^^^^^^^^^^
    -Vosco LDA
    Done: -Sort out Orbital category.  WF should not see OrbImp stuff.
    Done: -Sort out Ham category.  WF should not see OrbImp stuff.
    Done: -Sort out CD category.  WF should not see OrbImp stuff.
        
        
    -Done: Clean up factorial wigner 3j table init.  Too many calls.
    -G-orbs for gaussians?
    -Mesh re-org
        Done: -Support iterators.
        -Cluster should support MakeMesh
        Done: -Move Mesh.H up to interfaces level.
        Done: -get <ss|1/r12|ss> working.
        -Integration is doing two sets of loops
            1) eval BasisSet(r), loop over rs
            2) Integrate with weights, loop over ws.
            -Is better to just do a weighted eval with one loop?
                The weighted eval should then use the sqrt(W).
                Not always sqrt(W)!!!  i.e. charge integral.
        -use size() in VectorFunction<T>
            Got into a big mess with final overrider.
        Done: No -Do we really need separate Eval, and EvalGrad functions?
    
oml:
    **-SMAT does not support S+=Xpr
    -Support V*SymMat without including matrix.h
    -Vector constructors with fill arguments was a really bad idea.
    -GetColumn fails for SMatrix.

      
Priority 2:
    -Hunt for dynamic casts that can be removed using dynamic_cast iterator
    -Do something about the oml/imp includes.
        Done: -Stop deriving from StreamableObject  it is mostly static any way
        -Include binio in stream.h?
        -Move stream up from imp.
    Done:  Gone -Persistent base doesn't do anything.
    -PolarizedGaussianBS use std::set for std::vector<std::vector<int> >    Ls;
        
    
Priority 3:
    
    -Make a derived FitBasisSet->IrrepBS<real> which has all the extra needed just for fitting.
        -This would require separate derived classes like FitSGIrrepBasis derived from both SGIrrepBasis
        and FitBasisSet.
        -It can have a separate DB since no 4C integrals are required.

    -Do we need to store both J and K,  PolG just stores one ERI4.
        With separate Vee and Vxc it seems we need to store J and K separatly.
        We could just store JK=J-0.5*K to save space, but then we need a combined Ham term.
        How doe PolG do it with just J?
   -Until we get point group symmetry working, polarized Gaussians only have one IrrepBasisSet
        -Broke BasisSet persistence tests. Need to put back 
            PerRef<IntegralDatabase> int BSImp<T>
        Yes but only for the gradient, renamed accordingly.
    -typedefs for std::vector<Polarization>, std::vector<SMat>, List<RVec3>
    -Lattice unit tests?
    -template <class T> T Max(const std::vector<T>& v) in one place
    Done: -Mesh code re-write  use pairs of points/weights, also get rid of
        MeshBrowser 
        AngularMeshBrowser 
        RadialMeshBrowser 
    -LOts of one off indexing between ptr_vector and Vector: Support Vector[i] for zero based indexing?
    -If N_nucleus=1 (atom) leave out Vnn term.
    -Get rid of HeapDB<T>::operator==(const IntegralDataBase<T>& idb) const
    -Support SMatrix for Lapack solvers.
        Lapack uses the extra space in the full matrix as working space.
        So we end up converting to full anyway.  THis is just a convenience for the user.
     ??? the order of H, which may cause some problem in the qchem code.
    -SphericalGuassian accept different exponent ranges for each L.
    -Dynamically adjust kT ?
    
            
    -Design question:
        Who should own the Hamitonian ... right now SCFIterator is deleting it.
    Done: -Organize headers in the include folder.
       
    -Design FittedPolarizedCD stores pointer, PolarizedCD does not.
    -Set up a CMake build.  Run from vscode.
    
--------------------------------------------------------------------------------------
    Done: -Get rid of TwoLPlusOne
    Done -Do we still nee fast contraction functions?
    Done: -Design problem:  
        IrrepWaveFunction creates and hold an rc_ptr<const BasisSet> which is also copied into
        the Ortbitals object.  Updateing the orbital is done by:
        TIrrepBasisSetCommon<T>::CreateOrbitals.  But this function cannot just use this to create
        new orbitals, it needs the original rc_ptr.  Options:
        1) IrrepWaveFunction does and extra step to inject the rc_ptr.
            This means Orbital needs and Inject(rc_ptr<>) function.
    Done -LAParams for InverseOverlap are hard coded right now.  Need to re-org all basis set
     constructors with 3 versions
        1) HF orbitals needs LAPArams for secular eq.
        2) DFT orbitals needs LAPArams for secular eq. and separate set for inversion.
        3) DFT Vee, Vxc fitting, needs mesh and no LAParams.
      We will need a null Ortho type for LAParams for assertions.
    Done: -Cache reports
    Done: -Experiment with Latex markup for doxygen.  Works great!
    Done: -DumpScalarData keeps showing up everywhere, do we need it?
    Done: -IE::MakeInverse should take LAParams as argument.
    Done: -All templated classes should hold TIrrepBasisSet<T> pointers.
        Construct only accepts TIrrepBasisSet<T>* ?
        Test out with IrrepCD and TOrbitals
    Done: -FittedFunctionImp delete itsMesh crashed.  Who owns the mesh?
        Good use for rc_ptr.
    Done: -Break dependency BasisSet-->Orbitals in Build Orbitals.
    Done: -Clean up fitting code, it is unreadable right now.
    Done: -We need a different interface for a scaler fit client like Vxc and the charge density
            which uses D_ij rather than a fit basis.
    Done: -Invert dependency BasisSet--->Fitted function
    Done: -TIrrepBasisSetCommon<T>::SetFitOverlap should not be call DoFit,
        Should do ff->Update(sf);
    Done: -BasisSet is not an interface.
    Boring: -BasisSet needs a dynamic cast iterator.
    Done: -and BasisGroup should really be BasisSet.
    Done: -Get BasisSet out of BasisSet.
    Done: -DB GetRepulsion4C(bs_t ab,bs_t cd) return a view
    Done: -Stop caching RNLM inside GaussianCD
    Done: -CDCache into its own source files.

    Done: -Use enum Types2C {Overlap2C, Repulsion2C,Kinetic,Nuclear} between DB and IE
    Done: -Use one set of enums for Types2C {Overlap2C, Repulsion2C,Kinetic,Nuclear}

    Done: -Client code should provide a Mesh* when requesting integrals form the DB.
    Done: -Eliminate NumerialIE , Caller should supply the mesh.  Heap DB can call integral engine directly.
    Done: -Client code should not see DB, just ask BS for integrals.
    Done: -BasisSet should really be IrrepBasisSet, 
    Done: -HeapDB needs to be for whole basis set not just one irep.
    Done: -Make sure BasisSet->DB->IE is enforced
        Done: -This means it takes a BasisSet argument for every call.
            Done: Break DB--->BasisSet dependence 
            Done: We will need some reoerg to IE
                IEClient can access BS data
                DB holds some sort of group IE
            
            
        Done: -Clean up all the insert nonsense for DB, IE and BS
    Done: -Integral engine needs a different interface for analytic and numerical.
    Done: -Do we need indices support optr_vector1<> ?
    Done: -It seems we need a separate HeapDN for each basis set.  Make something more general
        enum type={Kinetic,Nuclear,Charge,Normalization,Overlap2C,Repulsion2C,Repulsion3C,Repulsion4C,Exchange4C,InversOverlap2C,InverseOverlap2C};
        map<{BasisID1,BasisID2,type},SMat>
        map<{BasisID1,BasisID2,type},Mat>
        map<{BasisID1,BasisID2,type},Vec>
        map<{BasisID1,BasisID2,type},ERI3>
        map<{BasisID1,BasisID2,type},ERI4>
        BasisID2=0 for one BS integrals.
        Handle swaps of BS 1 and 2?
    Done: -Reorg:  Do this on a branch!!!
        -Break dependence of IntegralEngine on BasisSet.
            Done: -For SG, IE gets a table of {alpha,L}
            -For PG, IE gets a table of {alpha,[l,m,n]}
            -For PCG , IE gets a table of {[alpha],[l,m,n]}
                -cache Charge distributions
                -cache RNML tables
    Done: -Instancing in one file: 
        IntegralEngine.C
        IntegralDataBase.C
    Done: -DFT stop using InverseOverlap ... use SVD solver or something more stable.
        Done: HeapDB is doing the inversion.  It has no business doing this.  Should be 
        moved to IE.  But HeapDB caches the overlap.
    Done: -Support std::vector std:;set streaming
    Done: -Migrate from OML Array<T> to std::vector<T>
    Done: -Migrate from OML List<T> to std::vector<T>,set<T>
    Done: -Range based iterators for ptr_vector and optr_vector.
    -Get rid of 
        Done OrbitalGroupIterator 
        Done OrbitalGroupBrowser 
        
        Done: BasisGroupBrowser
        Done: BasisSetBrowser
            Do we need iterator?
        Done: ClusterBrowser 
            Do we need iterator?
    -Done: Make a dynamic_cast iterator for optr_vector1, then get rid of
        Done TOrbitalGroupBrowser requires a dynamic cast iterator
        Done: TBasisSetBrowser requires a dynamic cast iterator

    -Instancing in one file: 
        Done: TBasisFunction.C
        Done: TBasisSet.C
        Done: TOrbital.C
    Done -Reorg SCFIterator and EigenSolvers  ->Rename LASolver
    Does OML eigen/SVD have a hard coded eps?
    Done: -Remove BasisSet.C PASolver.C QuantumNumber.C  ExFunctional.C
        Hamiltonain.C
        HamiltonianTerm.C
        Cluster.C
        Orbital.C
        PolarizedWF.C 
        FittedCD.C
    Done: -Set up LAParams and feed in BasisSetImp
        -tol for basis set orthogonalization
        -Linalg package Pkg=OML or Lapack
        -Basis set ortho method Ortho=SVD,Eigen,Cholsky
        -Eps for Eigen convergence.
        
    Done: -0 Need SCFConverge struct store
        -kT for thermal spreading of valance electron occupancies.
        -relax for Ro update.
        -epsRo minimum delta Ro
        -NMax maximum SCF iterations.
        -smear?  Same as kT?
    Done: -0.1 remove eps from Lapack SVD code,  not used!
    Done: 1 Need a way to feed tol, Lapack-eps, Pkg, Ortho enums into BasisSetImp or feed the solver in.
        Done: What is Lapack-eps?  Convergence?
    Done: -2 use 1 to make some UTs with all supported combos
    Done: -3 Use 2 to Harmonize Truncate routine for OML/Lapack SVD
    Done -Make a trim function to weed out small SV and EV solutions.  This will reduce
    Done: -Switch from ptr_vector to ptr_vector1.
    Done: -Start using optr_vector1 which is vastly simpler.
    Done -Fix all signed unsigned comparisons.
    Done: -Stop using ! for vector norm.

    Done: Import LAPACK code into oml and add to unit tests.
        Done: -Eigen dense symm
        -Eigen dense non sym
        -SVD dense
        -Linear system dense
        -Do we need sparse?
    Done: -Add some tests for IO of basis sets, waved functions, hamiltonians.
    Ansewred: -Way do we need default constructos for basisSet, Clusters, hamiltonians.
        Unpickle;
