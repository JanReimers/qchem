Priority 1:
    -Work towards linear contraction of D_cd*J_abcd and D_cd*K_abcd
        -Store K_abcd as SMatrix<Matrix> for a!=b and SMatrix<SMatrix> for a==b
        -Or SMatrix<SMatrix> = 0.5*(K_abcd+K_abcd)
    -SVD truncation ... we need no know which L is getting truncated.
    -Merge degen levels with diff m QNs.
        -Also make two column list of levels/occs
        -Get rid of ElectronDumper.
        -Merge/sort all levels for a given spin/l  
    -Upgrade iteration output.
        -More digits for virial.
        -Unused columns.
        -Mixing parameter.
        -Stream to a separate log file?
    -Do we need to do an SCF iter in Initialize?
    
    -SGm/SLm with f orbitals, K/J tables overlfow memory.  Probably 98% zeros.
        1) Check view blocks for all zeros.
        2) Us a two way cache K[irrep1,irrep2]
            Need to deal with Diag (ir1==ir2) and non-diag K tables (ir1!=ir2) .
    -Another round of warning fixes.
    -Sort out locations for QN headers
    -QchemTester: make show basis set an option.
    -Common base for SlaterCD and SG_CD
        -Make some unit test first?
    -Better name for SlaterScaler --> Slater::ExponentScaler,  same for Gaussian.  
        PG can be a typedef so SG::ExponentScaler?
    -Point group symmtery
        https://www.mantidproject.org/
            https://docs.mantidproject.org/v3.11.0/concepts/PointAndSpaceGroups.html
        https://jmol.sourceforge.net/
        https://pypi.org/project/PyPointGroup/
        https://www.sciencedirect.com/science/article/abs/pii/S0010465517300310
            https://data.mendeley.com/datasets/xd4g8hyjf2/1
        
    -use map hints for caches
    -Molecule mesh gives crappy integrals.  
        -Something wrong with Molecular mesh generation.
    -Print out electron configuration Sc: 1s2 2s2 2p6 3s2 3p6 4s1 4d2
    
    -Convergence acceleration.
        Should go in SCFIterator.
    -Document and make UTs for all the mesh types.
    -put periodic table in spreadsheet and read in a csv file.
        -Use python to read NIST DFT tables, and Hartree–Fock–Roothaan energies.txt
    -Fix valgrind errors
        Seeing 1 errors related open MP
        Atom mesh leaks.  Should own radial and angular meshes?
    -Clean up PolGaussian construction
        -PolarizedGaussianBS use std::set for std::vector<std::vector<int> >    Ls;
   
    -Clean up tech notes.
    -Make a new PolG::IntegralEngine using libcint
    -Why new SlaterExchange(exparam,Spin(Spin::Up)); for pol fit vxc?
                                    ^^^^^^^^^^^^^^
    -G-orbs for gaussians?
        Fixed -Hermite2 crashes for L=3 (f orbitals).
        Fixed -What are those horrible lookup tables!!
        Need to unit test with PG basis for uranium.
    -GaussianRF.C has its own DFact tables.  Use the global tables.
    
oml:
    **-SMAT does not support S+=Xpr
    -Support V*SymMat without including matrix.h
    -Vector constructors with fill arguments was a really bad idea.
    -GetColumn fails for SMatrix.
    -Subvector why in imp?
        Also infinite recursion:  VecLimits GetLimits() const {return static_cast<const Derived*>(this)->GetLimits();}

      
Priority 2:
    -Set up a CMake build.  Run from vscode.
    -ID, streaming
        1) Test boost::serialization, does it work for shared pointers???
            Looks like yes, can std::shared_ptr in the headers.
        -We need a non-streamable UniqueID for caching GuassianCD amd RNLM objects.
        -Separate UniquesID from streaming
        -Get rid of ALL the old Read/Write.  Put (intrusive>?) boost::serialization code in one place.
        -What about pretty output?
        -boost::serialization of OML objects.
        -Also consider cereal.
        -Does UniqueID really need to enforce Read/Write?
        Tightly couple with PMStreamableObject which is tightly coupled with
        the Read/Write functions throughout.
    -Use std::vector<std::unique_ptr<T> > preferrable to optr_vector<T*>
    -Try serializing with cereal.  
        -Goal is the dump a CD, load it back in to restart iterations.  Possibly for higher Z.
        -Need a mile high plan to io before doing anything.
        -Less include from oml/imp
        -Basis set
        -Charge densities.
        -Use CDs for starting SCF iterations.

    -What can we use from boost:
        -Filesystem
        -Flyweight for GaussianCD s?
        -Foreach looping
        -iostream state saver.
        -iterator
        -Logging
        -Multi-index containers
        -MySQL
        -Pointer container, poly-container
        -Program options
        -Python interface generation.
        -Range 
        -uBlas,
        -units
        -Uuid
        -Boost::Serialize is what we need for saving and restoring object trees.
            Talks about boost::shared_pointer ... too old for sdt::shared_ptr?
            Need to try.
            
    -Hunt for dynamic casts that can be removed using dynamic_cast iterator
    -Do something about the oml/imp includes.
        -Include binio in stream.h?
        -Move stream up from imp.
    -Vosco LDA
    
    
Priority 3:
    -SCFSupervisor class:
        Owns BS, H, WaveF, SCFIterator
        Lest important now that Ham, mash, aux basis handling is mostly automated.
    
    -Make a derived FitBasisSet->IrrepBS<real> which has all the extra needed just for fitting.
        -This would require separate derived classes like FitSGIrrepBasis derived from both SGIrrepBasis
        and FitBasisSet.
        -It can have a separate DB since no 4C integrals are required.

    -Do we need to store both J and K,  PolG just stores one ERI4.
        With separate Vee and Vxc it seems we need to store J and K separatly.
        We could just store JK=J-0.5*K to save space, but then we need a combined Ham term.
        How doe PolG do it with just J?
    -typedefs for std::vector<Polarization>, std::vector<SMat>, List<RVec3>
    -Lattice unit tests?
    -template <class T> T Max(const std::vector<T>& v) in one place
    -LOts of one off indexing between ptr_vector and Vector: Support Vector[i] for zero based indexing?
    -If N_nucleus=1 (atom) leave out Vnn term.
    -Get rid of HeapDB<T>::operator==(const IntegralDataBase<T>& idb) const
    -Support SMatrix for Lapack solvers.
        Lapack uses the extra space in the full matrix as working space.
        So we end up converting to full anyway.  THis is just a convenience for the user.
     ??? the order of H, which may cause some problem in the qchem code.
    
            
    -Design question:
        Who should own the Hamitonian ... right now SCFIterator is deleting it.
       
    -ROHF for one open orbital.
        -Need separate list of C and O orbitals in TOrbitals.
        -Literature makes no mention of Angular integrals and w3j symbols for K integrals.
        -Need coupling constants for d orbitals.
        -Understand what ERI4view.Exchange(a,b,c,d) is doing.
        -Polarized HF with m splitting basis works just well. Way less complicated.
    
--------------------------------------------------------------------------------------
Fixed:: -Electron loading problem/buf for Z=55 and up
        -Until we get point group symmetry working, polarized Gaussians only have one IrrepBasisSet
        -Broke BasisSet persistence tests. Need to put back 
            PerRef<IntegralDatabase> int BSImp<T>
        Yes but only for the gradient, renamed accordingly.
    No -Dynamically adjust kT ?
   Done: -SphericalGuassian accept different exponent ranges for each L.
    - Support SL/SLm/SG/SGm in a systematic manner
        Done: Common angular code.
        Common Dab code
        fk is different.
        Done: Do Angular integrals in blocks.
        Steps
        Done: 1) Separate sums for J K
            for J do
                loop ab
                Ak(l_ab,m_ab), Rk(l_ab,e_ab)
                  loop cd
                  Ak(l_cd,m_cd), Rk(l_cd,e_cd)
                    J=sum(k,Ak(ab)*Ak(cd)*{Rk(ab)+Rk(cd)+})
        No: 2) Can we cache Ak(ab), Rk(ab) ?  (instead of blocking)
            Blocking should be more efficient, less map<> lookups.
        Done: Shareable 4way cache.
    Done: -Fix Boron.
        The K integrals appear correct, at least for s & p orbitals in Boron.
        So why does PG work and SL fails?
        Because the in the PG basis occupied Px can split from py/pz, and give a small energy gain.
        For SL it is hard coded as one level with degen=2L+1=3.
        We would need to introduce the m QN number and allow m splitting, at least for valance shells.
    -Slater_m next steps now that Boron is working:
        Done: 1) Clean up data dumps.
        Done: 2) Get all UTas running again.
        Done: 3) Refactor out the angular parts with all the w3j symbols
        Done: 4) Build static wj3 tables using the wigner library.
        Done: 5) Get d orbitals working
        6) Try Sc again.
            Still difficult.  PG nails it.  Need to sort out all the factors of 4*Pi.
            No: 10) Get 4Pi^2 out of the integral engines.  Why?
            -Better to completely dis-entangle angular and radial.
            -Evaluate angular for whole blocks.  Less w3j lookups.
        Done: 7) Make a SG_m basis set.
            Done: We could optionally read the exponents and contractions from the BS files.
        Done: 8) 3C repulsions should call R_k(lalblcld) directly.
        Done: 9) Stop building zero density matrices.   And definitely don''t bother contracting them!!!
        11) Check for double calculation of J/K ERIs
    Done: -Survey Z=2-25
        Fixed: Big trouble starts at Sc.
    Done: -Attack Sc problem:
        1) Review angular integral theory
        2) Build PolGau BS with only primitives to match SGm exponents.  Look at J/K tables.
        3) Use libcint for Real-spheric GTOs and check against SGm.
            https://orbkit.github.io/dev/integrals/libcint.html
            https://github.com/ValeevGroup/libintx
        4) Done: Check high Z closed shell atoms.  If these are correct the d/f ERI integrals must be right .. No?
            SGm/SLm unpolarized *OR* polarized  all get Sr/Ba (38/56) wrong  d^2 instead of s^2 in the valance shell.
            options:
            4.1) Simulated anneal occupations with Fermi function.
            4.2) Electron dumper force s valance electrons
                For Sc we need to force 4s^2 (E=-0.21) or 3d^1 (E=-0.34) ... or both?
                
            4.3) Read in an accurate starting charge density.  (this could get complicated fast)
        
    Done: -Mesh code re-write  use pairs of points/weights, also get rid of
        MeshBrowser 
        AngularMeshBrowser 
        RadialMeshBrowser 
     Done: -Mesh re-org
        Done: -Support iterators.
        Done: -Move Mesh.H up to interfaces level.
        Done: -get <ss|1/r12|ss> working.
        -Integration is doing two sets of loops
            1) eval BasisSet(r), loop over rs
            2) Integrate with weights, loop over ws.
            -Is better to just do a weighted eval with one loop?
                The weighted eval should then use the sqrt(W).
                Not always sqrt(W)!!!  i.e. charge integral.
        -use size() in VectorFunction<T>
            Got into a big mess with final overrider.
        Done: No -Do we really need separate Eval, and EvalGrad functions?
   -Automate exponents for slater orbitals.  0.5->1.5*Z ?
        Done: for testing.
    Done: -Cluster should support CreateMesh
    Done: -Make final Ham types Ham_HF_U Ham_HF_P, Ham_DFT_U ... etc.
    Done: -Add A-PG_*_* tests.
    -STO basis set for atoms.
        -Type out the integral formulas
        Done: -Use a static pascal triangle for I_k calculations.
        Done: -Get maxL=4 working (f g functions)
            Done: Need to automate the I_k expressions using binomial sum. 
        -Decouple n=l+1.  i.e. multiple ns for one l.  look up max(n) for a given Z?
        -One alpha=Z/n basis function, to satisfy the cusp condition.
        Done: -Start coding the BF/BS/IE classes.
        Done: -Test the integrals with numerical integrations.
            Fixed: Numerical repulsion integrals don't give the right numbers.
    Fixed? -Design FittedPolarizedCD stores pointer, PolarizedCD does not.
    Done:  Gone -Persistent base doesn't do anything.
    Done: -Organize headers in the include folder.
    Done: -Get all headers into include.
    Done: -Re-org UT class network.  too many classes.
        Decouple
            Basis set type
            H type
                Some H types need fit basis sets.
            cluster type
                Some basis sets only work with atoms
        Use case:
    Done: -Sort out Orbital category.  WF should not see OrbImp stuff.
    Done: -Sort out Ham category.  WF should not see OrbImp stuff.
    Done: -Sort out CD category.  WF should not see OrbImp stuff.
        
        
    -Done: Clean up factorial wigner 3j table init.  Too many calls.
   Done: -Use BasisSet interface to create charge and Vxc fitting basis sets.
    Done: -Drop rc_ptr and use std::shared_ptr and std::unique_ptr.
        Done: FitFuncImp had shared_ptr for basis set and mesh.
        Use std:: for Cluster pointers.
    Done: -Fix all warnings.
    Done: -Get rid of TwoLPlusOne
    Done -Do we still nee fast contraction functions?
    Done: -Design problem:  
        IrrepWaveFunction creates and hold an rc_ptr<const BasisSet> which is also copied into
        the Ortbitals object.  Updateing the orbital is done by:
        TIrrepBasisSetCommon<T>::CreateOrbitals.  But this function cannot just use this to create
        new orbitals, it needs the original rc_ptr.  Options:
        1) IrrepWaveFunction does and extra step to inject the rc_ptr.
            This means Orbital needs and Inject(rc_ptr<>) function.
    Done -LAParams for InverseOverlap are hard coded right now.  Need to re-org all basis set
     constructors with 3 versions
        1) HF orbitals needs LAPArams for secular eq.
        2) DFT orbitals needs LAPArams for secular eq. and separate set for inversion.
        3) DFT Vee, Vxc fitting, needs mesh and no LAParams.
      We will need a null Ortho type for LAParams for assertions.
    Done: -Cache reports
    Done: -Experiment with Latex markup for doxygen.  Works great!
    Done: -DumpScalarData keeps showing up everywhere, do we need it?
    Done: -IE::MakeInverse should take LAParams as argument.
    Done: -All templated classes should hold TIrrepBasisSet<T> pointers.
        Construct only accepts TIrrepBasisSet<T>* ?
        Test out with IrrepCD and TOrbitals
    Done: -FittedFunctionImp delete itsMesh crashed.  Who owns the mesh?
        Good use for rc_ptr.
    Done: -Break dependency BasisSet-->Orbitals in Build Orbitals.
    Done: -Clean up fitting code, it is unreadable right now.
    Done: -We need a different interface for a scaler fit client like Vxc and the charge density
            which uses D_ij rather than a fit basis.
    Done: -Invert dependency BasisSet--->Fitted function
    Done: -TIrrepBasisSetCommon<T>::SetFitOverlap should not be call DoFit,
        Should do ff->Update(sf);
    Done: -BasisSet is not an interface.
    Boring: -BasisSet needs a dynamic cast iterator.
    Done: -and BasisGroup should really be BasisSet.
    Done: -Get BasisSet out of BasisSet.
    Done: -DB GetRepulsion4C(bs_t ab,bs_t cd) return a view
    Done: -Stop caching RNLM inside GaussianCD
    Done: -CDCache into its own source files.

    Done: -Use enum Types2C {Overlap2C, Repulsion2C,Kinetic,Nuclear} between DB and IE
    Done: -Use one set of enums for Types2C {Overlap2C, Repulsion2C,Kinetic,Nuclear}

    Done: -Client code should provide a Mesh* when requesting integrals form the DB.
    Done: -Eliminate NumerialIE , Caller should supply the mesh.  Heap DB can call integral engine directly.
    Done: -Client code should not see DB, just ask BS for integrals.
    Done: -BasisSet should really be IrrepBasisSet, 
    Done: -HeapDB needs to be for whole basis set not just one irep.
    Done: -Make sure BasisSet->DB->IE is enforced
        Done: -This means it takes a BasisSet argument for every call.
            Done: Break DB--->BasisSet dependence 
            Done: We will need some reoerg to IE
                IEClient can access BS data
                DB holds some sort of group IE
            
            
        Done: -Clean up all the insert nonsense for DB, IE and BS
    Done: -Integral engine needs a different interface for analytic and numerical.
    Done: -Do we need indices support optr_vector1<> ?
    Done: -It seems we need a separate HeapDN for each basis set.  Make something more general
        enum type={Kinetic,Nuclear,Charge,Normalization,Overlap2C,Repulsion2C,Repulsion3C,Repulsion4C,Exchange4C,InversOverlap2C,InverseOverlap2C};
        map<{BasisID1,BasisID2,type},SMat>
        map<{BasisID1,BasisID2,type},Mat>
        map<{BasisID1,BasisID2,type},Vec>
        map<{BasisID1,BasisID2,type},ERI3>
        map<{BasisID1,BasisID2,type},ERI4>
        BasisID2=0 for one BS integrals.
        Handle swaps of BS 1 and 2?
    Done: -Reorg:  Do this on a branch!!!
        -Break dependence of IntegralEngine on BasisSet.
            Done: -For SG, IE gets a table of {alpha,L}
            -For PG, IE gets a table of {alpha,[l,m,n]}
            -For PCG , IE gets a table of {[alpha],[l,m,n]}
                -cache Charge distributions
                -cache RNML tables
    Done: -Instancing in one file: 
        IntegralEngine.C
        IntegralDataBase.C
    Done: -DFT stop using InverseOverlap ... use SVD solver or something more stable.
        Done: HeapDB is doing the inversion.  It has no business doing this.  Should be 
        moved to IE.  But HeapDB caches the overlap.
    Done: -Support std::vector std:;set streaming
    Done: -Migrate from OML Array<T> to std::vector<T>
    Done: -Migrate from OML List<T> to std::vector<T>,set<T>
    Done: -Range based iterators for ptr_vector and optr_vector.
    -Get rid of 
        Done OrbitalGroupIterator 
        Done OrbitalGroupBrowser 
        
        Done: BasisGroupBrowser
        Done: BasisSetBrowser
            Do we need iterator?
        Done: ClusterBrowser 
            Do we need iterator?
    -Done: Make a dynamic_cast iterator for optr_vector1, then get rid of
        Done TOrbitalGroupBrowser requires a dynamic cast iterator
        Done: TBasisSetBrowser requires a dynamic cast iterator

    -Instancing in one file: 
        Done: TBasisFunction.C
        Done: TBasisSet.C
        Done: TOrbital.C
    Done -Reorg SCFIterator and EigenSolvers  ->Rename LASolver
    Does OML eigen/SVD have a hard coded eps?
    Done: -Remove BasisSet.C PASolver.C QuantumNumber.C  ExFunctional.C
        Hamiltonain.C
        HamiltonianTerm.C
        Cluster.C
        Orbital.C
        PolarizedWF.C 
        FittedCD.C
    Done: -Set up LAParams and feed in BasisSetImp
        -tol for basis set orthogonalization
        -Linalg package Pkg=OML or Lapack
        -Basis set ortho method Ortho=SVD,Eigen,Cholsky
        -Eps for Eigen convergence.
        
    Done: -0 Need SCFConverge struct store
        -kT for thermal spreading of valance electron occupancies.
        -relax for Ro update.
        -epsRo minimum delta Ro
        -NMax maximum SCF iterations.
        -smear?  Same as kT?
    Done: -0.1 remove eps from Lapack SVD code,  not used!
    Done: 1 Need a way to feed tol, Lapack-eps, Pkg, Ortho enums into BasisSetImp or feed the solver in.
        Done: What is Lapack-eps?  Convergence?
    Done: -2 use 1 to make some UTs with all supported combos
    Done: -3 Use 2 to Harmonize Truncate routine for OML/Lapack SVD
    Done -Make a trim function to weed out small SV and EV solutions.  This will reduce
    Done: -Switch from ptr_vector to ptr_vector1.
    Done: -Start using optr_vector1 which is vastly simpler.
    Done -Fix all signed unsigned comparisons.
    Done: -Stop using ! for vector norm.

    Done: Import LAPACK code into oml and add to unit tests.
        Done: -Eigen dense symm
        -Eigen dense non sym
        -SVD dense
        -Linear system dense
        -Do we need sparse?
    Done: -Add some tests for IO of basis sets, waved functions, hamiltonians.
    Ansewred: -Way do we need default constructos for basisSet, Clusters, hamiltonians.
        Unpickle;

        
        
        
        
