
Priority 1:
    -convert all enums into enum classes
        General clean as well.
    -Re-imagine Ylm basis sets.
        Based on electron config only *two* Irreps one for occupied and one for unoccupied.
        Each would be merge of Nocc or Nunocc m values.
        Ak and Rk would need to be avaraged or summed accordingly.
        For example for Boron
            Y_{1,-1} for occupied
            0.5*(Y_{1,0}+Y_{1,1}) for un-occupied.

    -openmp
        -Make some simple unit tests
        -Demostrate 3x real time improvement.
            -How to measure?  
                gtest seems to give longer run times for parallel?!?
                time command gives confusing output.
                check how oml UT gets times.
        -Try and get ERI4 contractions working
        -Direct and Exchange functions (more difficult)
            Need to use instance of cach4, rather then inherit?
                Once ERI4 is stored, we can throw out cache 4?
    -ptr_vector
        -Stop using.
            Done: BasisSet
            Done: Irrep_BS
            Deon: Orbital
            Polarized Gaussian
                Irrep_BS::blocks
                ContractedGaussianH3 H3s
                GaussianCD
                Composite_CD
            Done: Molecule
            Hamiltonian
        -Try std::vector<std::shared_ptr<T>>
        -What about iterators?
        -Retest with valgrind.
    -Total energy
        -Calculated in  SCFIteratorImp::DisplayEnergies
            and then re-calculated in SCFIteratorImp::Iterate
            DisplayEnergies should just return E_total
        -Total energy should not redo ERI4 contractions.
    -Orbital_QNs
        Use std::shared_ptr for sym.
    -Valgrind reporting problems in TOrbitalsImp
        Invalid read of size 8
            ==150119==    at 0x4E7B5F: dynamic_cast_iterator<Orbital*, TOrbital<double>*>::operator++(int) (ptr_vector.h:97)
            ==150119==    by 0x4E7780: TOrbitalsImp<double>::CalculateDensityMatrix() const (TOrbitals.C:112)
        Address 0x6509e00 is 0 bytes after a block of size 32 alloc'd
            ==150119==    at 0x4846FA3: operator new(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
            ==150119==    by 0x4E8DDE: std::__new_allocator<Orbital*>::allocate(unsigned long, void const*) (new_allocator.h:151)
            ==150119==    by 0x4E8B81: allocate (alloc_traits.h:478)
            ==150119==    by 0x4E8B81: std::_Vector_base<Orbital*, std::allocator<Orbital*> >::_M_allocate(unsigned long) (stl_vector.h:380)
            ==150119==    by 0x4E87D9: void std::vector<Orbital*, std::allocator<Orbital*> >::_M_realloc_append<Orbital*>(Orbital*&&) (vector.tcc:596)
            ==150119==    by 0x4E842E: Orbital*& std::vector<Orbital*, std::allocator<Orbital*> >::emplace_back<Orbital*>(Orbital*&&) (vector.tcc:123)
            ==150119==    by 0x4E7DD8: std::vector<Orbital*, std::allocator<Orbital*> >::push_back(Orbital*&&) (stl_vector.h:1301)
            ==150119==    by 0x4E7120: TOrbitalsImp<double>::UpdateOrbitals(Hamiltonian&, DM_CD const*) (TOrbitals.C:95)
        1) Switch from optr_vector1<Orbital*>  itsOrbitals; to std::vector<std::shared_ptr<Orbital>>
        Done: 2) Make a proper dyn-cast iterator.
    Done: Refactor iteratorproxies for BasisSet ad Orbitals.
        Inherit from a template?

    Done: -For kinetic energy split up grad^2 and centrifugal parts.
        -This is atom specific, does not ally to pol. Gaussians.
        Done: -Rename primative interals:
            Inv_r2 <a|1/r^2|b>
            Inv_r1 <a|1/r|b>
        centrifugal =l*(l+1)*Inv_r2(a,b)
        nuclear = -Z*Inv_r1(a,b)
        grad2=<a|d^2/dr^2|b>
        Also need a MeshIntegrator::Inv_r2 for the centrifugal term for 
    -Add BSpline basis sets.
        https://okruz.github.io/BSplinebasis does everything we need ...
            except that the spine order is hard coded.
                std::vector<std::array<T, ARRAY_SIZE>> _coefficients;
                This is so that the package can do compile time recusron for efficiency
            May have to hard code k=5,6,7,8,9
                Instance in one file
                If we instance K=9, does this automatically create instances for K=8,7,...,0 ?
                    Inside BSplinebasis maybe yes.
                    But qchem template would not recurse unless we set up that way.
                        Specialize K=0 to stop recusrion.
        Done: IE.C
            Done: fix loop ranges to exclude splines that do not overlap.
            Done: Need another BFGrouper for splines, can we make an op< for splines?
                Could properly sort based on 
        Done: BF how to take derivative of spline?
        No: Need to make a static list of H kinetic operators for L=0,1,2,3,4
            Separate out centrifugal term instead.
        Done: Ylm BSplines
        No: Use radial mesh interface for knot generation
            Implement Qiu's mesh
            1+1/h where h=2^m for exact float representation,  Now Rmax is not fixed.
            The radial mesh framework stores a weight for each node.  Spline breakpoins have no weight.
        Make a BSpline::Breakpoints typedef to std::vector<double>, or std::dqueue<double>
            Make Log from N,Rmin,Rmax or N,Rmin,m  
            Qiu's mesh, with linear for r<1.0 a.u.
            bool SupportScaling(index).  
            Option: Multiple knots at Rmax?
        Rk
            Done: Cache diagonal GLQ grids.
            Done: Optimize/inline intpow.  Not much effect.
            Cache off diagonal grid cells.  Which ones?  Calc on demand?  All?
            Cache diagonal grid cells.  Lots of them ... how often would they get reused?
                Try on demand and count cache hits.
            Try using scaling relations
            Done: -Do some profiling.
                spline::op(r) is the hot function.
        Done: Instance a fixed list K values
            How to make a map instances: https://softwareengineering.stackexchange.com/questions/390927/c-design-pattern-for-template-instantiation-based-on-run-time-information
        Add DFT support.
        
    -BSplines should use (symmetric) banded matricies for space/time efficiency.
    Fixed: -BSm basis fails for f-electrons (BS is fine)
        Also struggles for Z=21,37,53 but these are history depenedent
        Suggest a memory leak

    Done: -Does Spin need to be a class.  Just use the enum directly ... and make some helper functions like GetDegeneracy(s), etc.
    -WF list all oritals.  Don;t list so many un-occ orbitals.
        Only in DEBUG mode!?!
    -Try Cr Z=24 (6 unpaired!) unpolarized  ... way off!
    -Atom app needs to save state.
        Done: install cereal
        Done auto save to .qchem
        Also suport save as
        open
        Open recent

    Done: -ro relax starts at 0.5
        Show ro relax in output
    -Plotting:
        Orbitals:
            swap colour and line increments.
            Too many line Ylm basis sets!
                Just plot distinct eigen energies?
        Done: Charge density
            r^2*ro(r)
            r^2*{ro_up-ro_down}
        Done: Energy level diagram
            Use PlotObject2DLine for el lines.
        Done: Diagonal values plot for BS
            -SVD: plot SVs
            -Eigen: plot eigen values
            -Cholsky: plot diagonal.
        Done: Y and X axis labels. + graph title.
            Use UTF
        Put Atom name and electron config in title.
        NO legend if only one line.
        Missing features:
            1) Hide one axis (or set colour for one axis)
            2) Disable legend entries.


    -Energy levels:  Show unocc eigen values for spin down.
    Done: -ElectronContainer just adds confusion.  Merge into Orbital
    Done: -Some Orbital functions can be implemented at the Orbital level ... they just call virtual functions.
    -Fix orbital phases to 1s, 2p , 3d are always >0?
    -Get LMax from the periodic table.
        Done: Used the Atom_EC
        Add unti test.

    -Clean up naming for IterationParams.
        SCFParams
    -Get rid of SCFIterationParams::kT
    -It would be nice if Atom derived from Cluster.
    -BasisSet:
        Use tempered definition for exponents:
            e=alpha*beta^i i = 0 ... n-1
    -Try making a separate libqc_basis.a to enforce some modularity.
        -Porabaly need to make a libqc_base.a  with some common stuff.
        Try making a C++20 module
    -Ham reorg
        -Fix Dynamic_HT caching bug for DFT with >1 irrep.
        -Vxc->LDAxc->ExchangeFunctional  
            Can we get rid of LDAxc?
        Done: -Support no cd guess to init SCF proc.
    -Refactor radial/Slater/IBS-Common and radial/Gaussian/IBS-Common
        Most code except Norms can move up to the radial level.
        Minor consolidaton.
    -Use constexpr for building static lookup tables.
    -define LMAX in one place.  Might >1 versions, but still define in one place.
    -Use ml instead of m
    -DFT check for l>0 basis sets for fitting.
    -Slater norm takes n=l+1, Gaussian norm takes l.

    -Make a UI app with plotting
        -wxPython + matplotlib (python)
            -I hate wx only becuse I spent 90% of my time trying to get the stupid
             sizers to do what I want.
            -Need to make a python binding using
                1) SIP https://github.com/Python-SIP/sip
                    -Used this before
                    https://www.itopen.it/python-sip-c-bindings-experiments/
                    https://wiki.python.org/moin/SIP
                2) https://github.com/pybind/pybind11
                -Python bindings might be of interest anyway.
        -Matplot++ just does popup windows, hard to embbed ... which seems bizzare.
        -Gtkmm-PLplot https://tschoonj.github.io/gtkmm-plplot/index.html
            Looks primising,  workinside a GTK-C++ (gtkmm) app
            https://www.gtk.org/docs/language-bindings/cpp/
            Need to worry about GTK3 or GTK4 support
            GTK 2,3,4 comes with ubuntu linux
            -Use GLADE to generate UI code. Or Cambalache https://gitlab.gnome.org/jpu/cambalache
            -Read in ui files: https://gnome.pages.gitlab.gnome.org/gtkmm-documentation/chapter-builder.html

        -Gnuplot has a c++ interface.
        -XMGrace
        -Use own PLotting which has an XMGrace driver.
            Would need to make Gtkmm-PLplot driver.
            -The multigraph support got complex and buggy.  Maybe refactoring would fix it?
        -FLTK https://www.fltk.org/doc-1.4/basics.html
        -QT has many plotting widgets.
            -Has a designer like GLADE.

        

    Done: -Set up IE_Primatives interface for each basis set radial type.
        Done: Use an IE_Primatives* at the AtomIE level for all integrals.
        Done: Then move more basis set code down to the AtomIE level.
        How to make this work with something like BSpline basis which does not use
            exponential/exponents?
            - IE_Primatives should mostly calculate tables of integrals S_ab, T_ab, V_ab.
            - Is this just the old IE interface re-appearing?
    -Break up the BasisSet.H header
        Done: -Break out BasisFunction.H
        Done: -Break out IrrepBS.H
            DFT: Put IE,DB,IBS interfaces in one header?
            HF: 
            Fit:
        Done: -Same for AnalyticIE.H, HeapDB.H AtomIE.H ?
        -Make AnalyticIE.H -> IE_common.H
        -Make IE.H which just includes all IE types.
        Done: -Make Atom folder under Basis set.
            AtomIE.H -> IE_Common.h
            IE.H which just includes all atom IE types.

    -Experiment with SVD/Eig tol and cholsky decomp for near saturation basis sets.
    Done: TOrbital iterators?
    -Survey use of dynamic cast
        -Hunt for dynamic casts that can be removed using dynamic_cast iterator
        -SHould only be casting between interfaces
        -Can we pass around more specific interfaces?
    -Gaussian integrals use recursion, should use Fact[n]/pow(2,n)
        Can we use constexpr features here?
    
    


    

    -Make and atom app for testing basis sets
        -Z{range or list} -N, -e{min.max} -b{S,Sm,G,Gm} -dL{front,back} 
        -What command line arg system to use?
        -Output:
            Econfig, spin,  Etot, rel_err(ppm), occ levels (optinal).
    -linear contraction of D_cd*J_abcd and D_cd*K_abcd
        -Try -march=native -O3
    -List all 2LAs in one place an use them throughout.
        2LAs: IE,BF,IR,BS,DB,QN,WF,EL,PG,SL,SG,CL(Client),FF(Fit Function),CD (Charge distribution), 
        3LAs: Occ,SGm,SLm,ERI,IE_CL,Rho(Charge density), Pol, UnP
        Conventions
            Underscore between acronyms: IR_BS
        Done: -Document in Types.H
        
    -Overlap3C La==Lb, but La==Lc is not always true how???
    -Need to tighten up/specialize allowed errors in HF energies for all UTs.
    -SVD truncation ... we need no know which L is getting truncated.
    -Energy levels:
        List m values [-1 0 1]
            How:  Merge std::vector<qn> into 3p [-1 0 1]
                Should have common n,l
                call qn->Append(os);  just output m?
            Handled cases where Up (col 1) is degenerate and Dn (col 2) is less/non degen.
    -Stream output to a separate log file?
    
    -QchemTester: make show basis set an option.
    -Common base for Slater::RkEngine and SG_CD
        -Make some unit tests first?
    Done: -Better name for SlaterScaler --> Slater::ExponentScaler,  same for Gaussian.  
        PG can be a typedef so SG::ExponentScaler?
    -Point group symmtery
        https://www.mantidproject.org/
            https://docs.mantidproject.org/v3.11.0/concepts/PointAndSpaceGroups.html
        https://jmol.sourceforge.net/
        https://pypi.org/project/PyPointGroup/
        https://www.sciencedirect.com/science/article/abs/pii/S0010465517300310
            https://data.mendeley.com/datasets/xd4g8hyjf2/1
    -Slater_m, SG_m basis sets:
        Add real spherical harmonic angular functions for g(r).
        replace m with ml?  or m = {mj,ml} depending on context?
    -Distinguish multi center and single center basis sets.  Clone(RVec3)
    -Relativistic:
        https://github.com/drjuls/AMBiT/tree/master/src
        https://diracprogram.org/doku.php?id=start
        https://nubakery.org/scf/dhf.html
        https://github.com/compas/grasp
        https://github.com/BERTHA-4c-DKS/pybertha
        -Make some tech notes
        -Start coding
            -BasisFunctions
                Done: -Large: Derive from SGm or SLm?
                    -Multiply by CG coeffs for spherical spinor components.
                Done: -Small: Construct from Large.
                Done: -Quantum number: kappa: can infer j,l.
                    AtomQN = radial QN * Angular QNs
                    Done: -Right now AtomQN derived from YlmQN
                    DOne: -Try AtomQN {n,QN* Anglular}
                    Clean up LMax (multiple places)
                        -LMax for electron configurations should be 3
                        -LMax for basis sets/functions can be >3
                    Fix up GetN for O_kmj.
                -BasisSet
                    Done: -Slater_mj,  SG_mj
                    Done: -Loop over kappa
                    Done: -How to arrange L/S basis functions?
                        Have Dirac::IrrepBasisSet hold 
                            Slater_mj::LargeBasisSet ={gL1,gL2,gL3...gLN}
                            Slater_mj::SmallBasisSet ={gS1,gS2...gSN}
                            Have Dirac::IntegralEngine manage the matrix build.
                Done: -IECLient
                Done: -Integral engine
                    -Need a cross Kinetic integral calculator:  K(a,b) where a is a large BS, b is small.
            -Hamiltonian
                Done: -Dirac K, Ven
                Done: -How to enforce Basis set is correct for H?
                    No: -bool Relativistc() const=0 member for BS and H interfaces?
                    Done: -Dynamic cast from Orbital_IBS to Orbital_RKB_IBS
            No: -Wave function
                    No: -DiracWF {PolaraizedWF itsLarge, itsSmall}
                    Done: -L^alpha and S^alpha need to interact for kinetic energy matrix.
            -Run H
            -Add support J/K 2ERIs, Dirac Vee, Vxc
            -Run He, Li, Be, B ....
            -DFT support.
            -Finite size nucleus,  Ven_fs
            TODO:
            Done: -Small_IrrepIEClient::Norm() copies the kinetic code from Slater::IE ... ho to share?
        -Factors of 2
            -Exchange
                K_LSLS should be Matrix, not SMatrix
                We need a non symmetrix version of ERI4
            No: -Don't renormalize gS, make gS=1/(2*c)*OP*gL
                Should be able to remove -2* for kinetic matrix, and 0.5* for energy.
                This one could get messy. Commit first for easy back out.
            -Confirm (debunk) theory:
                the so call centrifugal part of the kinetic enegry l*(l+1)*(d/dr)*2
                should use the l corresponding to -kappa not the radial l.

            
    -use map hints for caches
        No such thing as map::hint for finding iterators.
    -Molecule mesh gives crappy integrals.  
        -Something wrong with Molecular mesh generation.
    -Print out electron configuration Sc: 1s2 2s2 2p6 3s2 3p6 4s1 4d2
    
    -Convergence acceleration.
        Should go in SCFIterator.
    -Document and make UTs for all the mesh types.
    -put periodic table in spreadsheet and read in a csv file.
        -Use python to read NIST DFT tables, and Hartree–Fock–Roothaan energies.txt
    -Fix valgrind errors
        Seeing 1 errors related open MP
        Atom mesh leaks.  Should own radial and angular meshes?
    -Clean up PolGaussian construction
        -PolarizedGaussianBS use std::set for std::vector<std::vector<int> >    Ls;
   
    -Clean up tech notes.
    -Make a new PolG::IntegralEngine using libcint
    -Why new SlaterExchange(exparam,Spin(Spin::Up)); for pol fit vxc?
                                    ^^^^^^^^^^^^^^
    -G-orbs for gaussians?
        Fixed -Hermite2 crashes for L=3 (f orbitals).
        Fixed -What are those horrible lookup tables!!
        Need to unit test with PG basis for uranium.
    -GaussianRF.C has its own DFact tables.  Use the global tables.
    
oml:
    (symmetric) banded matricies for space/time efficiency when using BSplines.
    **-SMAT does not support S+=Xpr
    -Support V*SymMat without including matrix.h
    -Vector constructors with fill arguments was a really bad idea.
    -GetColumn fails for SMatrix.
    -Subvector why in imp?
        Also infinite recursion:  VecLimits GetLimits() const {return static_cast<const Derived*>(this)->GetLimits();}
    Handle SMatrix<complex<T>> return conj is i>j;
        Very tough C++ issue.
    
      
Priority 2:
    Done: -Set up a CMake build.  Run from vscode.
    -ID, streaming
        1) Test boost::serialization, does it work for shared pointers???
            Looks like yes, can std::shared_ptr in the headers.
        -We need a non-streamable UniqueID for caching GaussianCD amd RNLM objects.
        Done: -Separate UniquesID from streaming
        -Get rid of ALL the old Read/Write.  Put (intrusive>?) boost::serialization code in one place.
        -What about pretty output?
        -boost::serialization of OML objects.
        -Also consider cereal.
        -Does UniqueID really need to enforce Read/Write?
        Tightly couple with PMStreamableObject which is tightly coupled with
        the Read/Write functions throughout.
    -Use std::vector<std::unique_ptr<T> > preferrable to optr_vector<T*>
    -Try serializing with cereal.  
        -Goal is the dump a CD, load it back in to restart iterations.  Possibly for higher Z.
        -Need a mile high plan to io before doing anything.
        -Less include from oml/imp
        -Basis set
        -Charge densities.
        -Use CDs for starting SCF iterations.

    -What can we use from boost:
        -Filesystem
        -Flyweight for GaussianCD s?
        -Foreach looping
        -iostream state saver.
        -iterator
        -Logging
        -Multi-index containers
        -MySQL
        -Pointer container, poly-container
        -Program options
        -Python interface generation.
        -Range 
        -uBlas,
        -units
        -Uuid
        -Boost::Serialize is what we need for saving and restoring object trees.
            Talks about boost::shared_pointer ... too old for sdt::shared_ptr?
            Need to try.
            
    -Do something about the oml/imp includes.
        -Include binio in stream.h?
        -Move stream up from imp.
    -Vosco LDA
    
    
Priority 3:
    -SCFSupervisor class:
        Owns BS, H, WaveF, SCFIterator
        Lest important now that Ham, mash, aux basis handling is mostly automated.
    
    -Make a derived FitBasisSet->IrrepBS<real> which has all the extra needed just for fitting.
        -This would require separate derived classes like FitSGIrrepBasis derived from both SGIrrepBasis
        and FitBasisSet.
        -It can have a separate DB since no 4C integrals are required.

    -Do we need to store both J and K,  PolG just stores one ERI4.
        With separate Vee and Vxc it seems we need to store J and K separatly.
        We could just store JK=J-0.5*K to save space, but then we need a combined Ham term.
        How doe PolG do it with just J?
    -typedefs for std::vector<Polarization>, std::vector<SMat>, List<RVec3>
    -Lattice unit tests?
    -template <class T> T Max(const std::vector<T>& v) in one place
    -LOts of one off indexing between ptr_vector and Vector: Support Vector[i] for zero based indexing?
    -If N_nucleus=1 (atom) leave out Vnn term.
    -Get rid of HeapDB<T>::operator==(const IntegralDataBase<T>& idb) const
    -Support SMatrix for Lapack solvers.
        Lapack uses the extra space in the full matrix as working space.
        So we end up converting to full anyway.  THis is just a convenience for the user.
     ??? the order of H, which may cause some problem in the qchem code.
    
            
    -Design question:
        Who should own the Hamitonian ... right now SCFIterator is deleting it.
       
    -ROHF for one open orbital.
        -Need separate list of C and O orbitals in TOrbitals.
        -Literature makes no mention of Angular integrals and w3j symbols for K integrals.
        -Need coupling constants for d orbitals.
        -Understand what ERI4view.Exchange(a,b,c,d) is doing.
        -Polarized HF with m splitting basis works just well. Way less complicated.
    
--------------------------------------------------------------------------------------
















    Done: -Get rid of AtomQN.
    Done: -Support LAPack::Cholsky.
    Done:-Need a more elegent version of
        std::pair<int,int> GetN(const int (&N)[4], const int (&Nv)[4], int NUnpaired) const=0;
        Perhaps: ValanceConfiguration GetN(const ElectronCOnfiguration&) const=0
    No: Move symmetries and EC classes into Atom and Molecule sections of Basis Set?
        Not sure where to put these.  Outside of basis sets we have:
            Atom_CL, Atom_EC Angular_Sym

    Done: -TOrbitalImp<T>::MakeEnergyLevel(const Spin& s) does not need the spin.
    Done: -Plot Orbitals
        Done: Use ScalerFunction interface.
            Add valarray op()(valarray x)
        No: Use VectorFunction interface for TOrbitals.
            Add vector<valarray> op()(valarray x)
        Done: TOrbitals are selected from the WF based on Irrep_QNs (which includes spin)
            We need a way to get a vector<Irrep_QNs> of allowed Irrep_QNs
            BS can supply a vector<const Symmetry*> which is spin agnostic.
                Pol_WF and UnPol-WF would need to add the spin aspect.
        How to plot orbitals
            Done: For UnPol plot
                1) Change line colour based on symmetry/Irrep_QNs
                2) Change line style (dashed dots etc) based principle QN
                3) Make unocc orbital 40% transparant
            Done: For Pol orbitals
                No -Easy solution is to just make two separate charts, but that hides the delta
                No-Three charts {up,dn,up-down} (Seomtimes the HOMO orbtial will occ for spin up and un occupied for spin down)
                No -Two charts {0.5*(up+dn),0.5*(up-down)}
                Done: -Use lines for spin up and dots for spin down.
            Done: Steps
                Done: 1) Get vector<const Symmetry*> from BS
                Done: 2) Request orbitals using 
                    UnPol Irrep_QNs(Spin::None,sym)
                    Pol Irrep_QNs(Spin::Up,sym) Irrep_QNs(Spin::Down,sym)
                Done: 3) Choose a x (really r) mesh: Linear or Log valarray<double> 
                Done: 4) Use VectorFunction vector<valarray> op()(valarray x)
                Done: 5) Make Pol and UnPol versions of OrbitalPlotWindow = Orital_PW
                Done: 6) HamFrame has Pol check box, so it can return correct type?
        Done: Clear Notebook


    Done:-Rethink WaveFunctions
        -WaveFunctionGroup should have 
            map<QN,IrrepWaveFunction*> All
            map<QN,IrrepWaveFunction*> Up //QNs are all spin up
            map<QN,IrrepWaveFunction*> Dn //QNs are all spin dn
            What about un-polarized?  ust use All list?
            But what is QN?  
                QuantumNumber* ?  NO  QNs can get cloned.
            -Use unordered_map and overload op==(const QuantumNumber*, const QuantumNumber*);
                COmpile error
                unordered_map<const QN&,WF*> also does not compile
            -In order to key on an abstract base.
            https://stackoverflow.com/questions/50180978/how-to-build-a-map-where-the-key-is-an-abstract-base-class-not-value
        Done:-Do we still need Pol and UnPol WFs?
            Yes, but they are ~contructor only classes.
        Done:-Do we need to do an SCF iter in Initialize?
            Done: -We should support new orbitals with charge density
                Results in Hydrogen like orbitals as an initial guess.

    Done: -QNs should contain spin.  Right?
        Yes
        Done: -But need to check that exchange integrals work out properly when spin is folded
            -Exchange requires a restricted sum over spinor-irreps
        into the Irrep blocking system.
            -Or put differently does spin interact differently then non-spin symmetry, with exchange interactions?
        Irrep QNs = IQNs
            {n,l,ml,ms},    g=1         NR open shell spin-unpaired atom
            {n,l,ml},       g=2         NR open shell spin paried atom
            {n,l,ms},       g=2l+1      NR open shell spin-unpaired atom
            {n,l},          g=2(2l+1)   NR closed shell atom
            {n,kappa,mj,ms} g=1         Dirac atom
            {n,kappa,ms}    g=2j+1      Dirac atom
            {n,chi,ms}      g=1         Molecule
            {n,chi}         g=2         Molecule
        -There are three concepts here:
            1) principle QN: n
            2) symmetry: Yl, Ylm, Point group
            3) spin.
            -For relativistic calculations the spherical spinor combines Ylm and spin.
             but I think we can still separate out spin.
        -Basis sets can be characterized by the symmetry part, but no by n,ms
        -Orbitals are of course characterized by all four QNs for polarized calculations
            and by n,sym for un polarized calculations.
            Orbitals should have a Spin.
        -We only need polymorphism for #2.
        -Need < op for std::maps<>
            This requires a hash value. (((n-1)*Nmax+l)*lmax+(ml+l))*lmax+(ms+0.5)
        -Need op== and MatchType(IQNs_a,IQNs_b)
        -Store j,mj,ms=n/2 QNs as double or some sort of frac class?
        -Plan:
            Done -QuantumNumber -> Symmetryfor brevity and plurality
            Done -Make a Irrep_QNs {ms,l,ml}
            Done -Make an Orbital_QNs class for {n,IrrepSymmetry}
            Done -Use OrbitalQNs->ms() instead of Spin s in WF,CD etc.
            No -Git rid of PolarizedCD
            No -Get rid of PolarizedWF.
        Done -I think we need the following associations:
            -Orbital_IBS has Symmetry = {l,ml} or {kappa} or {chi}
            -IrrepOrbitals has IrrepQNs = {ms,Symmetry}
            -Orbital has Orbital_QNs = {n,ms,Symmetry}
            -Could do IrrepQNs is just and Orbital_QNs with n=0.  But it would be better to
             use the type system to distinguish.
            -Are these related by containment or inheritance?
                Symmetry is polymorphic whihc suggest containment
                Irrep_QNs is not and Orbital_QNs, so again containment.
        -Do we still need AngularQN (Yes) and AtomQN (No)?


    Done: -Break up BasisSet folder
        Done: Atom
            radial
            l
                Slater,Gaussian,BSpline
            ml 
                Slater,Gaussian,BSpline
            RKB
                Slater,Gaussian,BSpline
        Done: Molecule
            PG
        Done: Lattice
            PlaneWave




    Done: -FittedFunctionImp should not be storing  
        SMat     itsInvOvlp;
        SMat     itsInvRepl; 
        Just use the DB caching mechanism.    
    Done: -We need separate interface for ExactCD as compared to FittedCD.
        i.e. Exchange(const Orbtial_HF_IBS&) only makes sense for ExactCD.
    Done: -Move all Hamilton constants out of integral engines
        Done: factor of 1/2 for kinetic
        factor of Z (and R) for Ven
            -Easy for atoms
            -For molecules This is inefficenet, we only need the sum over centers
        Done: factors of c for H_Dirac
    Fixed: -SGm/SLm with f orbitals, K/J tables overlfow memory.  Probably 98% zeros.
        1) Check view blocks for all zeros.
        Done: 2) Us a two way cache K[irrep1,irrep2]
            Done: Need to deal with Diag (ir1==ir2) and non-diag K tables (ir1!=ir2) .
    Done: -Another round of warning fixes.
    Done: -Survey use of IrrepBS, Can we use more specific interfaces?
    Done: -RKBS_IE::Kinetic should call IE_Primatives::Kinetic
    Done: -SlaterIntegral(alpha,n) includes r^2 in n
        GaussianIntegral(alpha,n) does not 
        Harmonize.
    Done: -Break down integral engines
        -OneElectron_IE:
            Overlap
            Nuclear
            Kinetic
        -DFT_IE->OneElectronIE Adds
            Repulsion2
            Overlap3
            Repulsion3
        -HF_IE->OneElectronIE Adds
            Direct4
            Exchange4
        -Fit_IE
            ?
        -Can add more later for observables opertors.
        Done: -COnjunction with:
            1) Simplify integral call chain
            2) Separate FitBasisSet idea.
    Done: -Use the DB_BS_2E to cache all integrals.
        -The reorg IE/DB/AtomIE classes so that we don't end up with Kinetic/Nuclear integrals
         poluting the FIT_IE interface.
    Done: -Simplify integral call chain
        -Adding RestMass integral calculation was very labourious.  Call Chain:
        HamTerm->IrrepBasisSet->IntegralDataBase->IntegralEngine
        -Should we at least get the basis set out of the call chain?
        -Reimagine in conjunction with Separate FitBasisSet idea.
    
    Done: -Get LAParams out of all the constructors.
        Use defaults, and have a optional Set() method.
    Done: -Clean up Dirac/RKB code.
    Done: -We need a UniqueID pure interface   
        Also separate from PMStreamable.
    Done: -Stop using paramaterized Integral() calls.
    Done: -PG::Fit_BS do we need all that function forwarding?
    Done: -Make Atom_BS_IE which handles and angular integrals for all atom basis sets.
    Done: -Need more iterators for BasisSet where dyn casting is done by the iterator.
        -Use proxy classes 
            for (auto b:bs->Irreps<TOrbital_IBS<double> >()) 
    Done: -1) Refactor atom IEs, lots of common code.
        Done: 2) Then propagate and new ERIJ ERIK code to all atom basis sets.
        Done: Oops: 3) Compare table sizes before removing old JK code.
        Done: -Store K_abcd as SMatrix<Matrix> for a!=b and SMatrix<SMatrix> for a==b
        Done: 4) -Or SMatrix<SMatrix> = 0.5*(K_abcd+K_abcd)
    Done: -Merge degen levels with diff m QNs.
        Done: -Also make two column list of levels/occs
        Done: -Get rid of ElectronDumper.
        Done: -Merge/sort all levels for a given spin/l  
    Done: -Upgrade iteration output.
        Done: -More digits for virial.
        Done: -Unused columns.
        Done: -Mixing parameter.
    Done: -Sort out locations for QN headers
    Fixed:: -Electron loading problem/buf for Z=55 and up
        -Until we get point group symmetry working, polarized Gaussians only have one IrrepBasisSet
        -Broke BasisSet persistence tests. Need to put back 
            PerRef<IntegralDatabase> int BSImp<T>
        Yes but only for the gradient, renamed accordingly.
    No -Dynamically adjust kT ?
   Done: -SphericalGaussian accept different exponent ranges for each L.
    - Support SL/SLm/SG/SGm in a systematic manner
        Done: Common angular code.
        Common Dab code
        fk is different.
        Done: Do Angular integrals in blocks.
        Steps
        Done: 1) Separate sums for J K
            for J do
                loop ab
                Ak(l_ab,m_ab), Rk(l_ab,e_ab)
                  loop cd
                  Ak(l_cd,m_cd), Rk(l_cd,e_cd)
                    J=sum(k,Ak(ab)*Ak(cd)*{Rk(ab)+Rk(cd)+})
        No: 2) Can we cache Ak(ab), Rk(ab) ?  (instead of blocking)
            Blocking should be more efficient, less map<> lookups.
        Done: Shareable 4way cache.
    Done: -Fix Boron.
        The K integrals appear correct, at least for s & p orbitals in Boron.
        So why does PG work and SL fails?
        Because the in the PG basis occupied Px can split from py/pz, and give a small energy gain.
        For SL it is hard coded as one level with degen=2L+1=3.
        We would need to introduce the m QN number and allow m splitting, at least for valance shells.
    -Slater_m next steps now that Boron is working:
        Done: 1) Clean up data dumps.
        Done: 2) Get all UTas running again.
        Done: 3) Refactor out the angular parts with all the w3j symbols
        Done: 4) Build static wj3 tables using the wigner library.
        Done: 5) Get d orbitals working
        6) Try Sc again.
            Still difficult.  PG nails it.  Need to sort out all the factors of 4*Pi.
            No: 10) Get 4Pi^2 out of the integral engines.  Why?
            -Better to completely dis-entangle angular and radial.
            -Evaluate angular for whole blocks.  Less w3j lookups.
        Done: 7) Make a SG_m basis set.
            Done: We could optionally read the exponents and contractions from the BS files.
        Done: 8) 3C repulsions should call R_k(lalblcld) directly.
        Done: 9) Stop building zero density matrices.   And definitely don''t bother contracting them!!!
        11) Check for double calculation of J/K ERIs
    Done: -Survey Z=2-25
        Fixed: Big trouble starts at Sc.
    Done: -Attack Sc problem:
        1) Review angular integral theory
        2) Build PolGau BS with only primitives to match SGm exponents.  Look at J/K tables.
        3) Use libcint for Real-spheric GTOs and check against SGm.
            https://orbkit.github.io/dev/integrals/libcint.html
            https://github.com/ValeevGroup/libintx
        4) Done: Check high Z closed shell atoms.  If these are correct the d/f ERI integrals must be right .. No?
            SGm/SLm unpolarized *OR* polarized  all get Sr/Ba (38/56) wrong  d^2 instead of s^2 in the valance shell.
            options:
            4.1) Simulated anneal occupations with Fermi function.
            4.2) Electron dumper force s valance electrons
                For Sc we need to force 4s^2 (E=-0.21) or 3d^1 (E=-0.34) ... or both?
                
            4.3) Read in an accurate starting charge density.  (this could get complicated fast)
        
    Done: -Mesh code re-write  use pairs of points/weights, also get rid of
        MeshBrowser 
        AngularMeshBrowser 
        RadialMeshBrowser 
     Done: -Mesh re-org
        Done: -Support iterators.
        Done: -Move Mesh.H up to interfaces level.
        Done: -get <ss|1/r12|ss> working.
        -Integration is doing two sets of loops
            1) eval BasisSet(r), loop over rs
            2) Integrate with weights, loop over ws.
            -Is better to just do a weighted eval with one loop?
                The weighted eval should then use the sqrt(W).
                Not always sqrt(W)!!!  i.e. charge integral.
        -use size() in VectorFunction<T>
            Got into a big mess with final overrider.
        Done: No -Do we really need separate Eval, and EvalGrad functions?
   -Automate exponents for slater orbitals.  0.5->1.5*Z ?
        Done: for testing.
    Done: -Cluster should support CreateMesh
    Done: -Make final Ham types Ham_HF_U Ham_HF_P, Ham_DFT_U ... etc.
    Done: -Add A-PG_*_* tests.
    -STO basis set for atoms.
        -Type out the integral formulas
        Done: -Use a static pascal triangle for I_k calculations.
        Done: -Get maxL=4 working (f g functions)
            Done: Need to automate the I_k expressions using binomial sum. 
        -Decouple n=l+1.  i.e. multiple ns for one l.  look up max(n) for a given Z?
        -One alpha=Z/n basis function, to satisfy the cusp condition.
        Done: -Start coding the BF/BS/IE classes.
        Done: -Test the integrals with numerical integrations.
            Fixed: Numerical repulsion integrals don't give the right numbers.
    Fixed? -Design FittedPolarizedCD stores pointer, PolarizedCD does not.
    Done:  Gone -Persistent base doesn't do anything.
    Done: -Organize headers in the include folder.
    Done: -Get all headers into include.
    Done: -Re-org UT class network.  too many classes.
        Decouple
            Basis set type
            H type
                Some H types need fit basis sets.
            cluster type
                Some basis sets only work with atoms
        Use case:
    Done: -Sort out Orbital category.  WF should not see OrbImp stuff.
    Done: -Sort out Ham category.  WF should not see OrbImp stuff.
    Done: -Sort out CD category.  WF should not see OrbImp stuff.
        
        
    -Done: Clean up factorial wigner 3j table init.  Too many calls.
   Done: -Use BasisSet interface to create charge and Vxc fitting basis sets.
    Done: -Drop rc_ptr and use std::shared_ptr and std::unique_ptr.
        Done: FitFuncImp had shared_ptr for basis set and mesh.
        Use std:: for Cluster pointers.
    Done: -Fix all warnings.
    Done: -Get rid of TwoLPlusOne
    Done -Do we still nee fast contraction functions?
    Done: -Design problem:  
        IrrepWaveFunction creates and hold an rc_ptr<const BasisSet> which is also copied into
        the Ortbitals object.  Updateing the orbital is done by:
        TIrrepBasisSetCommon<T>::CreateOrbitals.  But this function cannot just use this to create
        new orbitals, it needs the original rc_ptr.  Options:
        1) IrrepWaveFunction does and extra step to inject the rc_ptr.
            This means Orbital needs and Inject(rc_ptr<>) function.
    Done -LAParams for InverseOverlap are hard coded right now.  Need to re-org all basis set
     constructors with 3 versions
        1) HF orbitals needs LAPArams for secular eq.
        2) DFT orbitals needs LAPArams for secular eq. and separate set for inversion.
        3) DFT Vee, Vxc fitting, needs mesh and no LAParams.
      We will need a null Ortho type for LAParams for assertions.
    Done: -Cache reports
    Done: -Experiment with Latex markup for doxygen.  Works great!
    Done: -DumpScalarData keeps showing up everywhere, do we need it?
    Done: -IE::MakeInverse should take LAParams as argument.
    Done: -All templated classes should hold TIrrepBasisSet<T> pointers.
        Construct only accepts TIrrepBasisSet<T>* ?
        Test out with IrrepCD and TOrbitals
    Done: -FittedFunctionImp delete itsMesh crashed.  Who owns the mesh?
        Good use for rc_ptr.
    Done: -Break dependency BasisSet-->Orbitals in Build Orbitals.
    Done: -Clean up fitting code, it is unreadable right now.
    Done: -We need a different interface for a scaler fit client like Vxc and the charge density
            which uses D_ij rather than a fit basis.
    Done: -Invert dependency BasisSet--->Fitted function
    Done: -TIrrepBasisSetCommon<T>::SetFitOverlap should not be call DoFit,
        Should do ff->Update(sf);
    Done: -BasisSet is not an interface.
    Boring: -BasisSet needs a dynamic cast iterator.
    Done: -and BasisGroup should really be BasisSet.
    Done: -Get BasisSet out of BasisSet.
    Done: -DB GetRepulsion4C(bs_t ab,bs_t cd) return a view
    Done: -Stop caching RNLM inside GaussianCD
    Done: -CDCache into its own source files.

    Done: -Use enum Types2C {Overlap2C, Repulsion2C,Kinetic,Nuclear} between DB and IE
    Done: -Use one set of enums for Types2C {Overlap2C, Repulsion2C,Kinetic,Nuclear}

    Done: -Client code should provide a Mesh* when requesting integrals form the DB.
    Done: -Eliminate NumerialIE , Caller should supply the mesh.  Heap DB can call integral engine directly.
    Done: -Client code should not see DB, just ask BS for integrals.
    Done: -BasisSet should really be IrrepBasisSet, 
    Done: -HeapDB needs to be for whole basis set not just one irep.
    Done: -Make sure BasisSet->DB->IE is enforced
        Done: -This means it takes a BasisSet argument for every call.
            Done: Break DB--->BasisSet dependence 
            Done: We will need some reoerg to IE
                IEClient can access BS data
                DB holds some sort of group IE
            
            
        Done: -Clean up all the insert nonsense for DB, IE and BS
    Done: -Integral engine needs a different interface for analytic and numerical.
    Done: -Do we need indices support optr_vector1<> ?
    Done: -It seems we need a separate HeapDN for each basis set.  Make something more general
        enum type={Kinetic,Nuclear,Charge,Normalization,Overlap2C,Repulsion2C,Repulsion3C,Repulsion4C,Exchange4C,InversOverlap2C,InverseOverlap2C};
        map<{BasisID1,BasisID2,type},SMat>
        map<{BasisID1,BasisID2,type},Mat>
        map<{BasisID1,BasisID2,type},Vec>
        map<{BasisID1,BasisID2,type},ERI3>
        map<{BasisID1,BasisID2,type},ERI4>
        BasisID2=0 for one BS integrals.
        Handle swaps of BS 1 and 2?
    Done: -Reorg:  Do this on a branch!!!
        -Break dependence of IntegralEngine on BasisSet.
            Done: -For SG, IE gets a table of {alpha,L}
            -For PG, IE gets a table of {alpha,[l,m,n]}
            -For PCG , IE gets a table of {[alpha],[l,m,n]}
                -cache Charge distributions
                -cache RNML tables
    Done: -Instancing in one file: 
        IntegralEngine.C
        IntegralDataBase.C
    Done: -DFT stop using InverseOverlap ... use SVD solver or something more stable.
        Done: HeapDB is doing the inversion.  It has no business doing this.  Should be 
        moved to IE.  But HeapDB caches the overlap.
    Done: -Support std::vector std:;set streaming
    Done: -Migrate from OML Array<T> to std::vector<T>
    Done: -Migrate from OML List<T> to std::vector<T>,set<T>
    Done: -Range based iterators for ptr_vector and optr_vector.
    -Get rid of 
        Done OrbitalGroupIterator 
        Done OrbitalGroupBrowser 
        
        Done: BasisGroupBrowser
        Done: BasisSetBrowser
            Do we need iterator?
        Done: ClusterBrowser 
            Do we need iterator?
    -Done: Make a dynamic_cast iterator for optr_vector1, then get rid of
        Done TOrbitalGroupBrowser requires a dynamic cast iterator
        Done: TBasisSetBrowser requires a dynamic cast iterator

    -Instancing in one file: 
        Done: TBasisFunction.C
        Done: TBasisSet.C
        Done: TOrbital.C
    Done -Reorg SCFIterator and EigenSolvers  ->Rename LASolver
    Does OML eigen/SVD have a hard coded eps?
    Done: -Remove BasisSet.C PASolver.C QuantumNumber.C  ExFunctional.C
        Hamiltonain.C
        HamiltonianTerm.C
        Cluster.C
        Orbital.C
        PolarizedWF.C 
        FittedCD.C
    Done: -Set up LAParams and feed in BasisSetImp
        -tol for basis set orthogonalization
        -Linalg package Pkg=OML or Lapack
        -Basis set ortho method Ortho=SVD,Eigen,Cholsky
        -Eps for Eigen convergence.
        
    Done: -0 Need SCFConverge struct store
        -kT for thermal spreading of valance electron occupancies.
        -relax for Ro update.
        -epsRo minimum delta Ro
        -NMax maximum SCF iterations.
        -smear?  Same as kT?
    Done: -0.1 remove eps from Lapack SVD code,  not used!
    Done: 1 Need a way to feed tol, Lapack-eps, Pkg, Ortho enums into BasisSetImp or feed the solver in.
        Done: What is Lapack-eps?  Convergence?
    Done: -2 use 1 to make some UTs with all supported combos
    Done: -3 Use 2 to Harmonize Truncate routine for OML/Lapack SVD
    Done -Make a trim function to weed out small SV and EV solutions.  This will reduce
    Done: -Switch from ptr_vector to ptr_vector1.
    Done: -Start using optr_vector1 which is vastly simpler.
    Done -Fix all signed unsigned comparisons.
    Done: -Stop using ! for vector norm.

    Done: Import LAPACK code into oml and add to unit tests.
        Done: -Eigen dense symm
        -Eigen dense non sym
        -SVD dense
        -Linear system dense
        -Do we need sparse?
    Done: -Add some tests for IO of basis sets, waved functions, hamiltonians.
    Ansewred: -Way do we need default constructos for basisSet, Clusters, hamiltonians.
        Unpickle;

        
        
        
        
