Done: -Support std::vector std:;set streaming
Done: -Migrate from OML Array<T> to std::vector<T>
Done: -Migrate from OML List<T> to std::vector<T>,set<T>
    
    -SMAT does not support S+=Xpr
    -Support V*S without including matrix.h
    -typedefs for std::vector<Polarization>, std::vector<SMat>, List<RVec3>
    Done: -Range based iterators for ptr_vector and optr_vector.
    -Lattice unit tests?
    -template <class T> T Max(const std::vector<T>& v) in one place
    -Get ride of 
        Done OrbitalGroupIterator 
        Done OrbitalGroupBrowser 
        
        Done: BasisGroupBrowser
        Done: BasisSetBrowser
            Do we need iterator?
        Done: ClusterBrowser 
            Do we need iterator?

        TwoLPlusOne
    -Done: Make a dynamic_cast iterator for optr_vector1, then get rid of
        Done TOrbitalGroupBrowser requires a dynamic cast iterator
        Done: TBasisSetBrowser requires a dynamic cast iterator
    -Mesh code re-write  use pairs of points/weights, also get rid of
        MeshBrowser 
        AngularMeshBrowser 
        RadialMeshBrowser 
    Done: -Switch from ptr_vector to ptr_vector1.
    -LOts of one off indexing between ptr_vector and Vector: Support Vector[i] for zero based indexing?
    Done: -Start using optr_vector1 which is vastly simpler.
    -PolarizedGaussianBS use std::set for std::vector<std::vector<int> >    Ls;
    Done -Fix all signed unsigned comparisons.
    -Do we need indices support optr_vector1<> ?
    -Hunt for dynamic casts that can be removed using dynamic_cast iterator
    Done: -Stop using ! for vector norm.
    -Do something about the oml/imp includes.
        Done: -Stop deriving from StreamableObject  it is mostly static any way
        -Include binio in stream.h?
        -Move stream up from imp.
    -Add some tests for IO of basis sets, waved functions, hamiltonians.
    -Import LAPACK code into oml and add to unit tests.
        Done: -Eigen dense symm
        -Eigen dense non sym
        -SVD dense
        -Linear system dense
        -Do we need sparse?
    -If N_nucleus=1 (atom) leave out Vnn term.
    -Get rid of HeapDB<T>::operator==(const IntegralDataBase<T>& idb) const
    -Persistent base doesn't do anything.
    -It seems we need a separate HeapDN for each basis set.  Make something more general
        enum type={Kinetic,Nuclear,Charge,Normalization,Overlap2C,Repulsion2C,Repulsion3C,Repulsion4C,Exchange4C,InversOverlap2C,InverseOverlap2C};
        map<{BasisID1,BasisID2,type},SMat>
        map<{BasisID1,BasisID2,type},Mat>
        map<{BasisID1,BasisID2,type},Vec>
        map<{BasisID1,BasisID2,type},ERI3>
        map<{BasisID1,BasisID2,type},ERI4>
        BasisID2=0 for one BS integrals.
        Handle swaps of BS 1 and 2?
    -Support SMatrix for Lapack solvers.
        Lapack uses the extra space in the full matrix as working space.
        So we end up converting to full anyway.  THis is just a convenience for the user.
    Done -Make a trim function to weed out small SV and EV solutions.  This will reduce
     the order of H, which may cause some problem in the qchem code.
    -SphericalGuassian accept different exponent ranges for each L.
    -Dynamically adjust kT ?
    
    -0 Need SCFConverge struct store
        -kT for thermal spreading of valance electron occupancies.
        -tol for basis set orthogonalization
        -Linalg package Pkg=OML or Lapack
        -Basis set ortho method Ortho=SVD,Eigen,Cholsky
        -Eps for Eigen convergence.
        -relax for Ro update.
        -epsRo minimum delta Ro
        -NMax maximum SCF iterations.
        -smear?  Same as kT?
    -0.1 remove eps from Lapack SVD code,  not used!
    Done: 1 Need a way to feed tol, Lapack-eps, Pkg, Ortho enums into BasisSetImp or feed the solver in.
        Done: What is Lapack-eps?  Convergence?
    Dene: -2 use 1 to make some UTs with all supported combos
    -3 Use 2 to Harmonize Truncate routine for OML/Lapack SVD
    -DFT stop using InverseOverlap ... use SVD solver or something more stable.
    -Design problem:  
        IrrepWaveFunction creates and hold an rc_ptr<const BasisSet> which is also copied into
        the Ortbitals object.  Updateing the orbital is done by:
        TBasisSetImplementation<T>::CreateOrbitals.  But this function cannot just use this to create
        new orbitals, it needs the original rc_ptr.  Options:
        1) IrrepWaveFunction does and extra step to inject the rc_ptr.
            This means Orbital needs and Inject(rc_ptr<>) function.
            
    -Way do we need default constructos for basisSet, Clusters, hamiltonians.
    -Design question:
        Who should own the Hamitonian ... right now SCFIterator is deleting it.
    Done -Reorg SCFIterator and EigenSolvers  ->Rename LASolver
    -Organize headers in the include folder.
    Does OML eigen/SVD have a hard coded eps?
