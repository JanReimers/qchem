Done: -Support std::vector std:;set streaming
Done: -Migrate from OML Array<T> to std::vector<T>
Done: -Migrate from OML List<T> to std::vector<T>,set<T>
    
    -SMAT does not support S+=Xpr
    -Support V*S without including matrix.h
    -typedefs for std::vector<Polarization>, std::vector<SMat>, List<RVec3>
    Done: -Range based iterators for ptr_vector and optr_vector.
    -Lattice unit tests?
    -template <class T> T Max(const std::vector<T>& v) in one place
    -Get ride of 
        Done OrbitalGroupIterator 
        Done OrbitalGroupBrowser 
        
        Done: BasisGroupBrowser
        Done: BasisSetBrowser
            Do we need iterator?
        Done: ClusterBrowser 
            Do we need iterator?

        TwoLPlusOne
    -Done: Make a dynamic_cast iterator for optr_vector1, then get rid of
        Done TOrbitalGroupBrowser requires a dynamic cast iterator
        Done: TBasisSetBrowser requires a dynamic cast iterator
    -Mesh code re-write  use pairs of points/weights, also get rid of
        MeshBrowser 
        AngularMeshBrowser 
        RadialMeshBrowser 
    Done: -Switch from ptr_vector to ptr_vector1.
    -LOts of one off indexing between ptr_vector and Vector: Support Vector[i] for zero based indexing?
    Done: -Start using optr_vector1 which is vastly simpler.
    -PolarizedGaussianBS use std::set for std::vector<std::vector<int> >    Ls;
    Done -Fix all signed unsigned comparisons.
    -Do we need indices support optr_vector1<> ?
    -Hunt for dynamic casts that can be removed using dynamic_cast iterator
    Done: -Stop using ! for vector norm.
    -Do something about the oml/imp includes.
        Done: -Stop deriving from StreamableObject  it is mostly static any way
        -Include binio in stream.h?
        -Move stream up from imp.
    -Add some tests for IO of basis sets, waved functions, hamiltonians.
    -Import LAPACK code into oml and add to unit tests.
        Done: -Eigen dense symm
        -Eigen dense non sym
        -SVD dense
        -Linear system dense
        -Do we need sparse?
    -If N_nucleus=1 (atom) leave out Vnn term.
    -Get rid of HeapDB<T>::operator==(const IntegralDataBase<T>& idb) const
    -Persistent base doesn't do anything.
    -It seems we need a separate HeapDN for each basis set.  Make something more general
        enum type={Kinetic,Nuclear,Charge,Normalization,Overlap2C,Repulsion2C,Repulsion3C,Repulsion4C,Exchange4C,InversOverlap2C,InverseOverlap2C};
        map<{BasisID1,BasisID2,type},SMat>
        map<{BasisID1,BasisID2,type},Mat>
        map<{BasisID1,BasisID2,type},Vec>
        map<{BasisID1,BasisID2,type},ERI3>
        map<{BasisID1,BasisID2,type},ERI4>
        BasisID2=0 for one BS integrals.
        Handle swaps of BS 1 and 2?
    -Use SMatrix for most integrals, and Hamiltonian matrices.
