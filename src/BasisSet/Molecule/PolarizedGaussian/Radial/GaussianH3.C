// File: GaussianH3.C   Class for managing 3 function Hermite coefficients.



#include "PolarizedGaussian/Radial/GaussianH3.H"
#include <iostream>
#include <cassert>
namespace PolarizedGaussian
{
//----------------------------------------------------------------------------------------
//
//  None of this will make any sense unless you read McMurchie and Davidson,
//  J. Comp. Phys. 26, 218 (1978).  Even then it may not make sense!!!
//


//----------------------------------------------------------------------------------------
//
//  Construction zone.
//

GaussianH3::GaussianH3()
    : itsLA   (0)
    , itsLB   (0)
    , itsLC   (0)
    , itsScale(-1.0)
{};

GaussianH3::GaussianH3(double AlphaP, const RVec3& PA, const RVec3& PB, const RVec3& PC, int LA, int LB, int LC, double Scale)
    : itsLA   (LA)
    , itsLB   (LB)
    , itsLC   (LC)
    , itsScale(Scale)
{
    double a12=1.0/(2*AlphaP);
    itsa12s[0]=1.0;
    for (int n=1; n<=itsLA+itsLB+itsLC; n++) itsa12s[n]=itsa12s[n-1]*a12;

//
//  For n<=N we can load em up.
//
    for (int n=0; n<=itsLA+itsLB+itsLC; n++)
        for (int na=0; na<=n && na<=itsLA; na++)
            for (int nb=0; nb<=n && nb<=itsLB; nb++)
                for (int nc=0; nc<=n && nc<=itsLC; nc++)
                {
                    int tn=na+nb+nc;
                    if (tn < n)
                    {
                        d[n][na][nb][nc] = 0;
                        e[n][na][nb][nc] = 0;
                        f[n][na][nb][nc] = 0;
                    }
                    if (tn == n)
                    {
                        d[n][na][nb][nc] = itsa12s[n];
                        e[n][na][nb][nc] = itsa12s[n];
                        f[n][na][nb][nc] = itsa12s[n];
                    }
                }

    for (int n=0; n<=itsLA+itsLB+itsLC; n++)
    {
//
//  For N<n we need to use the recusion relations.
//
        for (int N=0; N<n ; N++)
        {

            int na_low=n-itsLB-itsLC;
            if (na_low<0) na_low=0;
            for (int na=na_low; na<=n && na<=itsLA; na++)
            {
                int nb_low=n-na-itsLC;
                if (nb_low<0) nb_low=0;
                for (int nb=nb_low; nb<=n-na && nb<=itsLB; nb++)
                {
                    int nc=n-na-nb;


                    if (na > 0)
                    {
                        d[N][na][nb][nc] = Getd(N-1,na-1,nb,nc)*a12 + Getd(N,na-1,nb,nc)*PA.x + Getd(N+1,na-1,nb,nc)*(N+1);
                        e[N][na][nb][nc] = Gete(N-1,na-1,nb,nc)*a12 + Gete(N,na-1,nb,nc)*PA.y + Gete(N+1,na-1,nb,nc)*(N+1);
                        f[N][na][nb][nc] = Getf(N-1,na-1,nb,nc)*a12 + Getf(N,na-1,nb,nc)*PA.z + Getf(N+1,na-1,nb,nc)*(N+1);
                    }
                    else //na = 0.
                    {
                        if (nb > 0)
                        {
                            d[N][na][nb][nc] = Getd(N-1,na,nb-1,nc)*a12 + Getd(N,na,nb-1,nc)*PB.x + Getd(N+1,na,nb-1,nc)*(N+1);
                            e[N][na][nb][nc] = Gete(N-1,na,nb-1,nc)*a12 + Gete(N,na,nb-1,nc)*PB.y + Gete(N+1,na,nb-1,nc)*(N+1);
                            f[N][na][nb][nc] = Getf(N-1,na,nb-1,nc)*a12 + Getf(N,na,nb-1,nc)*PB.z + Getf(N+1,na,nb-1,nc)*(N+1);
                        }
                        else //na && nb = 0.
                        {
                            if (nc > 0)
                            {
                                d[N][na][nb][nc] = Getd(N-1,na,nb,nc-1)*a12 + Getd(N,na,nb,nc-1)*PC.x + Getd(N+1,na,nb,nc-1)*(N+1);
                                e[N][na][nb][nc] = Gete(N-1,na,nb,nc-1)*a12 + Gete(N,na,nb,nc-1)*PC.y + Gete(N+1,na,nb,nc-1)*(N+1);
                                f[N][na][nb][nc] = Getf(N-1,na,nb,nc-1)*a12 + Getf(N,na,nb,nc-1)*PC.z + Getf(N+1,na,nb,nc-1)*(N+1);
                            }
                        }
                    }


                } //nb
            } //na
        } //N
    } //n
}


double GaussianH3::GetAny(const Array4D def, int N, int na, int nb, int nc) const
{
//  cout << "(N,n1,n2) = (" << N << "," << na << "," << nb << ")" << std::endl;
    assert(N <=itsLA+itsLB+itsLC);
    assert(na<=itsLA            );
    assert(nb<=itsLB            );
    assert(nc<=itsLC            );
//
//  Take care of negative n's generated by derivatives of distributions.
//
    if ( na < 0 || nb < 0 || nc < 0 || N < 0) return 0.0;

    int n=na+nb+nc; // we now know that na, nb and nc are >=0.
//
//  All other 0.0 elements.
//
    if (N >  n) return 0.0;
//
//  Take care of trivial elemnts.  We know n1 and n2 are >=0.
//
    if (n==N) return itsa12s[n];
//
//  Use fancy indexing to get at the numbers
//
    return def[N][na][nb][nc];
}

//#if DEBUG
double GaussianH3::operator()(const Polarization& Pa,const Polarization& Pb,const Polarization& Pc) const
{
//  cout << Pa << Pb << Pc << " " << itsLA << " " << itsLB << " " << itsLC << std::endl;
    if (Pa.GetTotalL() >itsLA)
    {
        std::cerr << "Hermite 3 overflow for Pa (Pa,Pb,Pc)=(" << Pa << "," << Pb << "," << Pc << ")  (La,Lb,Lc)=)" << itsLA << "," << itsLB << "," << itsLC << ")" << std::endl;
    }
    if (Pb.GetTotalL() >itsLB)
    {
        std::cerr << "Hermite 3 overflow for Pb (Pa,Pb,Pc)=(" << Pa << "," << Pb << "," << Pc << ")  (La,Lb,Lc)=)" << itsLA << "," << itsLB << "," << itsLC << ")" << std::endl;
    }
    if (Pc.GetTotalL() >itsLC)
    {
        std::cerr << "Hermite 3 overflow for Pc (Pa,Pb,Pc)=(" << Pa << "," << Pb << "," << Pc << ")  (La,Lb,Lc)=)" << itsLA << "," << itsLB << "," << itsLC << ")" << std::endl;
    }
    assert(Pa.GetTotalL()<=itsLA);
    assert(Pb.GetTotalL()<=itsLB);
    assert(Pc.GetTotalL()<=itsLC);
//  cout << "Pa=" << Pa << " Pb=" << Pb << " Pc=" << Pc << " itsScale " << itsScale << " d=" << d[0][Pa.n][Pb.n][Pc.n]
//    << " e=" << e[0][Pa.l][Pb.l][Pc.l] << " f=" << f[0][Pa.m][Pb.m][Pc.m] << std::endl;
    return itsScale * d[0][Pa.n][Pb.n][Pc.n] * e[0][Pa.l][Pb.l][Pc.l] * f[0][Pa.m][Pb.m][Pc.m];
}
//#endif
/*
//
//  Assumes Scale=0.0 indicates no data yet.
//
void GaussianH3::Add(const GaussianH3& h3, double AddingScale)
{
//  cout << "GaussianH3::Add       LA,LB,LC " << itsLA << "," << itsLB << "," << itsLC << std::endl;
//  cout << "GaussianH3::Add other LA,LB,LC " << h3.itsLA << "," <<  h3.itsLB << "," <<  h3.itsLC << std::endl;
  if (itsScale==-1.0)
  {
//    cout << "GaussianH3::Add clearing" << std::endl;
    itsScale=1.0;
    itsLA=h3.itsLA;
    itsLB=h3.itsLB;
    itsLC=h3.itsLC;
  }
   else
  {
    if (itsLA != h3.itsLA) F_Error("GaussianH3::Add LA's don't match");
    if (itsLB != h3.itsLB) F_Error("GaussianH3::Add LB's don't match");
    if (itsLC != h3.itsLC) F_Error("GaussianH3::Add LC's don't match");
  }

  for (int n=0;n<=itsLA;n++)
    for (int l=0;l<=itsLB;l++)
      for (int m=0;m<=itsLC;m++)
      {
	d[0][n][l][m]+=AddingScale*h3.d[0][n][l][m];
	e[0][n][l][m]+=AddingScale*h3.e[0][n][l][m];
	f[0][n][l][m]+=AddingScale*h3.f[0][n][l][m];
      }
}

void GaussianH3::Clear()
{
  for (int n=0;n<=itsLA;n++)
    for (int l=0;l<=itsLB;l++)
      for (int m=0;m<=itsLC;m++)
      {
	d[0][n][l][m]=0.0;
	e[0][n][l][m]=0.0;
	f[0][n][l][m]=0.0;
      }
  for(int i=0;i<=itsLA+itsLB+itsLC;i++) itsa12s[i]=0.0;
  itsScale=-1.0;
  itsLA=0; itsLB=0;itsLC=0;
}

*/

std::ostream& operator<<(std::ostream& os,const GaussianH3& h3)
{
    os << "scale " << h3.itsScale << ", LA " << h3.itsLA << ", LB " << h3.itsLB << ", LC " << h3.itsLC << std::endl;

    os << "N=" << 0 << std::endl;
    for (int na=0; na<=h3.itsLA; na++)
    {
        for (int nb=0; nb<=h3.itsLB; nb++)
        {
            for (int nc=0; nc<=h3.itsLC; nc++)
            {
                Polarization p(na,nb,nc),z(0,0,0);
                os << h3(p,p,z) << " ";
            }
            os << std::endl;
        }
        os << std::endl;
    }
    os << std::endl;

    os << "N=" << 0 << std::endl;
    for (int na=0; na<=h3.itsLA; na++)
    {
        for (int nb=0; nb<=h3.itsLB; nb++)
        {
            for (int nc=0; nc<=h3.itsLC; nc++) os << h3.d[0][na][nb][nc] << " ";
            os << std::endl;
        }
        os << std::endl;
    }
    os << std::endl;
    os << "L=" << 0 << std::endl;
    for (int na=0; na<=h3.itsLA; na++)
    {
        for (int nb=0; nb<=h3.itsLB; nb++)
        {
            for (int nc=0; nc<=h3.itsLC; nc++) os << h3.e[0][na][nb][nc] << " ";
            os << std::endl;
        }
        os << std::endl;
    }
    os << std::endl;
    os << "M=" << 0 << std::endl;
    for (int na=0; na<=h3.itsLA; na++)
    {
        for (int nb=0; nb<=h3.itsLB; nb++)
        {
            for (int nc=0; nc<=h3.itsLC; nc++) os << h3.f[0][na][nb][nc] << " ";
            os << std::endl;
        }
        os << std::endl;
    }
    os << std::endl;

    /*for (int N=0; N<=h3.itsLA+h3.itsLB+h3.itsLC;N++)
    {
    os << "N=" << N << std::endl;
      for (int na=0;na<=h3.itsLA;na++)
      {
        for (int nb=0;nb<=h3.itsLB;nb++)
        {
    for (int nc=0;nc<=h3.itsLC;nc++) os << h3.d[N][na][nb][nc] << " ";
    os << std::endl;
        }
        os << std::endl;
      }
      os << std::endl;
    }
    for (int N=0; N<=h3.itsLA+h3.itsLB+h3.itsLC;N++)
    {
    os << "L=" << N << std::endl;
      for (int na=0;na<=h3.itsLA;na++)
      {
        for (int nb=0;nb<=h3.itsLB;nb++)
        {
    for (int nc=0;nc<=h3.itsLC;nc++) os << h3.e[N][na][nb][nc] << " ";
    os << std::endl;
        }
        os << std::endl;
      }
      os << std::endl;
    }
    for (int N=0; N<=h3.itsLA+h3.itsLB+h3.itsLC;N++)
    {
    os << "M=" << N << std::endl;
      for (int na=0;na<=h3.itsLA;na++)
      {
        for (int nb=0;nb<=h3.itsLB;nb++)
        {
    for (int nc=0;nc<=h3.itsLC;nc++) os << h3.f[N][na][nb][nc]  << " ";
    os << std::endl;
        }
        os << std::endl;
      }
      os << std::endl;
    }
    */
    return os;
}

} //namespace PolarizedGaussian
