// File: Hermite1.C



#include "Imp/BasisSet/PolarizedGaussian/MnD/Hermite1.H"
#include "Misc/IntPower.H"
#include "oml/imp/binio.h"
#include "oml/imp/stream.h"
#include <iostream>
#include <cassert>

//----------------------------------------------------------------------------------------
//
//  None of this will make any sense unless you read McMurchie and Davidson,
//  J. Comp. Phys. 26, 218 (1978).
//


//----------------------------------------------------------------------------------------
namespace PolarizedGaussian
{


Hermite1::Hermite1()
    : itsL(0)
{}



Hermite1::Hermite1(double AlphaP, int L)
    : itsL(L)
{
    double a12=1.0/(2*AlphaP);

    for (int n=0; n<=itsL; n++)
        for (int N=0; N<=itsL; N++) def[N][n] = Getdef(N-1,n-1)*a12 + Getdef(N+1,n-1)*(N+1);
}


double Hermite1::Getdef(int N, int n) const
{
    assert(N<=itsL+1);
    assert(n<=itsL  );
//
//  Take care of negative n's generated by derivatives of distributions.
//
    if ( n < 0 || N < 0) return 0.0;
//
//  Take care of s-s charge distributions.  We know n1 and n2 are >=0.
//
    if (n==0 && N==0) return 1.0;
//
//  All other 0.0 elements.
//
    if (N >  n) return 0.0;
//
//  Use fancy indexing to get at the numbers
//
    return def[N][n];
}


double Hermite1::operator()(const Polarization& P,const Polarization& Pa) const
{
//  cout << "(N,n1,n2) = (" << N << "," << na << "," << nb << ")" << std::endl;
    assert(P .n<=itsL);
    assert(Pa.n<=itsL);
    assert(P .l<=itsL);
    assert(Pa.l<=itsL);
    assert(P .m<=itsL);
    assert(Pa.m<=itsL);
//
//  Take care of negative n's generated by derivatives of distributions.
//
    if ( Pa.n < 0 || P.n < 0) return 0.0;
    if ( Pa.l < 0 || P.l < 0) return 0.0;
    if ( Pa.m < 0 || P.m < 0) return 0.0;

//
//  All other 0.0 elements.
//
    if (P.n>Pa.n || P.l>Pa.l || P.m>Pa.m ) return 0.0;
//
//  Take care of s-s charge distributions.  We know n1 and n2 are >=0.
//
    double retd=0.0, rete=0.0, retf=0.0;
    if (Pa.n==0 && P.n==0) retd=1.0;
    if (Pa.l==0 && P.l==0) rete=1.0;
    if (Pa.m==0 && P.m==0) retf=1.0;
//
//  Use fancy indexing to get at the numbers
//
    if (retd==0.0) retd = def[P.n][Pa.n];
    if (rete==0.0) rete = def[P.l][Pa.l];
    if (retf==0.0) retf = def[P.m][Pa.m];
    return retd * rete * retf;
}

void Hermite1::Add(const Hermite1& h1, double AddingScale)
{
    if (itsL<0)
        itsL=h1.itsL;
    else
        assert(itsL == h1.itsL);

    for (int n=0; n<=itsL; n++)
        for (int N=0; N<=itsL; N++)
            def[N][n]+=AddingScale*h1.def[N][n];
}

void Hermite1::Clear()
{
    for (int n=0; n<=itsL; n++)
        for (int N=0; N<=itsL; N++)
            def[N][n]=0.0;
    itsL=-1;
}


std::ostream& Hermite1::Write(std::ostream& os) const
{
    if (StreamableObject::Binary())
    {
        BinaryWrite(itsL,os);
        for (int N=0; N<=itsL; N++)
            for (int n=0; n<=itsL; n++)
                BinaryWrite(def[N][n],os);
    }
    if (StreamableObject::Ascii())
    {
        os << itsL << " ";
        for (int N=0; N<=itsL; N++)
            for (int n=0; n<=itsL; n++)
                os << def[N][n] << " ";
    }
    if (StreamableObject::Pretty())
    {
        os << ": L=" << itsL << std::endl;
        os.precision(4);
        os.width(8);
        os.setf(std::ios::fixed,std::ios::floatfield);
        for (int N=0; N<=itsL; N++)
        {
            os << "---------------------------------------------------------------------" << std::endl;
            os << "N = " << N << std::endl;
            for (int n=0; n<=itsL; n++)
            {
                os << Getdef(N,n) << " ";
                os << std::endl;
            }
        }
    }
    return os;
}

std::istream& Hermite1::Read (std::istream& is)
{
    if (StreamableObject::Binary())
    {
        BinaryRead(itsL,is);
        for (int N=0; N<=itsL; N++)
            for (int n=0; n<=itsL; n++)
                BinaryRead(def[N][n],is);
    }
    if (StreamableObject::Ascii())
    {
        is >> itsL;
        for (int N=0; N<=itsL; N++)
            for (int n=0; n<=itsL; n++)
                is >> def[N][n];
    }
    return is;
}

Hermite1* Hermite1::Clone() const
{
    return new Hermite1(*this);
}


} //namespace PolarizedGaussian
